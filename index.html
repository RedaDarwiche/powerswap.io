<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PowerSwap.io</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="favicon.png?v=2">

    
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    
    <style>
        :root {
            --primary: #00f2fe;
            --secondary: #4facfe;
            --accent: #ff0055;
            --dark: #0f172a;
            --surface: rgba(15, 23, 42, 0.85);
            --glass-border: rgba(255, 255, 255, 0.15);
            --success: #10b981;
            --warning: #f59e0b;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-font-smoothing: antialiased; }
        
        body {
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
            background-color: var(--dark);
            color: white;
            height: 100vh;
            width: 100vw;
        }

        #gameCanvas { position: absolute; top: 0; left: 0; z-index: 1; }
        #ui-layer { position: absolute; inset: 0; z-index: 10; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }

        .glass-panel {
            background: var(--surface);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            color: white;
        }

        .btn-neon {
            background: linear-gradient(135deg, var(--secondary), var(--primary));
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            color: #0f172a;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 1px;
            box-shadow: 0 0 20px rgba(0, 242, 254, 0.3);
        }
        .btn-neon:hover { filter: brightness(1.2); transform: translateY(-2px); }
        .btn-neon:active { transform: translateY(0); }
        .btn-neon:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        .btn-text {
            background: transparent; 
            border: 1px solid rgba(255,255,255,0.3);
            color: rgba(255,255,255,0.8);
            cursor: pointer; 
            font-weight: 700; 
            font-size: 0.9rem; 
            margin-top: 12px;
            padding: 12px 24px;
            border-radius: 8px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            width: 100%;
        }
        .btn-text:hover { 
            color: white; 
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.5);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
        }
        .btn-secondary:hover { background: rgba(255,255,255,0.2); }

        input.modern-input, textarea.modern-input, select.modern-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--glass-border);
            padding: 12px;
            border-radius: 8px;
            color: white;
            font-family: inherit;
            margin-bottom: 12px;
            outline: none;
            transition: border-color 0.2s;
        }
        input.modern-input:focus, select.modern-input:focus, textarea.modern-input:focus { border-color: var(--primary); }

        #top-left-ui { position: absolute; top: 20px; left: 20px; z-index: 2000; display: flex; flex-direction: column; align-items: flex-start; gap: 10px; }
        #top-right-ui { position: absolute; top: 20px; right: 20px; z-index: 2000; display: flex; gap: 10px; }

        #user-profile {
            display: flex; align-items: center; gap: 10px;
            background: rgba(0,0,0,0.8); padding: 8px 20px; border-radius: 50px;
            border: 1px solid var(--glass-border);
        }

        #main-menu {
            position: absolute; inset: 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle at center, rgba(15, 23, 42, 0.95), #020617);
            z-index: 100;
        }

        h1.logo {
            font-size: 5rem; font-weight: 900;
            background: linear-gradient(to right, #00f2fe, #4facfe);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
        }

        .menu-card { width: 100%; max-width: 400px; text-align: center; }

        #hud-bottom {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: none; flex-direction: column; align-items: center; gap: 10px; z-index: 50;
        }

        .power-slot {
            width: 80px; height: 80px;
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            display: flex; justify-content: center; align-items: center;
            position: relative; transition: all 0.3s;
        }
        .power-slot.active {
            border-color: var(--primary);
            box-shadow: 0 0 30px rgba(0, 242, 254, 0.4);
            background: rgba(0, 242, 254, 0.1);
        }
        .power-slot.omega-active {
            animation: omegaPulse 0.5s infinite;
            border-color: #ffd700;
        }
        .power-slot.speed-active {
            animation: speedPulse 0.5s infinite;
        }
        @keyframes speedPulse {
            0%, 100% { box-shadow: 0 0 30px rgba(239, 68, 68, 0.6); }
            50% { box-shadow: 0 0 50px rgba(239, 68, 68, 1); }
        }
        @keyframes omegaPulse {
            0%, 100% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
            50% { box-shadow: 0 0 50px rgba(255, 0, 128, 1); }
        }
        .key-hint {
            position: absolute; bottom: -45px; width: 200px; text-align: center;
            font-size: 0.8rem; font-weight: bold; opacity: 0.8;
            display: flex; flex-direction: column; gap: 2px;
        }

        #kill-counter {
            position: absolute; bottom: 158px; left: 50%; transform: translateX(-50%);
            display: none; z-index: 50;
            background: rgba(0,0,0,0.7);
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            border: 1px solid rgba(255,255,255,0.2);
        }
        #kill-counter.close-to-omega {
            animation: killCounterPulse 1s infinite;
            border-color: #ffd700;
        }
        @keyframes killCounterPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 1); }
        }

        #leaderboard {
            position: absolute; top: 70px; right: 20px;
            width: 200px; display: none; z-index: 50;
        }
        .lb-header {
            font-size: 1rem; font-weight: 800; color: var(--primary);
            border-bottom: 1px solid var(--glass-border);
            padding-bottom: 8px; margin-bottom: 8px;
            display: flex; justify-content: space-between;
        }
        .lb-row {
            display: flex; justify-content: space-between;
            padding: 5px 0; font-size: 0.9rem; color: rgba(255,255,255,0.8);
        }
        .lb-row.me { color: white; font-weight: bold; text-shadow: 0 0 10px var(--primary); }

        #chat-wrap {
            position: absolute; bottom: 20px; left: 20px; width: 350px; display: none; z-index: 50;
        }
        #chat-history {
            height: 200px; overflow-y: auto;
            mask-image: linear-gradient(to bottom, transparent, black 10%);
            margin-bottom: 10px; display: flex; flex-direction: column; justify-content: flex-end;
        }
        .chat-msg { margin-bottom: 5px; font-size: 0.9rem; }

        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.8);
            backdrop-filter: blur(8px); z-index: 3000;
            display: none; justify-content: center; align-items: center;
        }
        .modal-content {
            width: 90%; max-width: 450px; position: relative;
            animation: slideUp 0.3s ease-out;
            max-height: 90vh; overflow-y: auto;
        }
        @keyframes slideUp { from { transform: translateY(30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        
        .close-btn {
            position: absolute; top: 15px; right: 20px;
            font-size: 1.5rem; cursor: pointer; color: rgba(255,255,255,0.5);
        }
        .close-btn:hover { color: white; }

        #forum-posts { 
            max-height: 420px; 
            overflow-y: auto; 
            margin-top: 16px;
            padding-right: 4px;
            scroll-behavior: smooth;
        }
        #forum-posts::-webkit-scrollbar { width: 4px; }
        #forum-posts::-webkit-scrollbar-track { background: transparent; }
        #forum-posts::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }
        #forum-posts::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }
        .modal-content::-webkit-scrollbar { width: 4px; }
        .modal-content::-webkit-scrollbar-track { background: transparent; }
        .modal-content::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }
        .forum-post {
            background: rgba(15, 23, 42, 0.6);
            padding: 18px;
            border-radius: 10px;
            margin-bottom: 10px;
            position: relative;
            border: 1px solid rgba(255,255,255,0.08);
            transition: border-color 0.2s, background 0.2s;
        }
        .forum-post:hover {
            border-color: rgba(255,255,255,0.18);
            background: rgba(15, 23, 42, 0.8);
        }
        .forum-post h4 { 
            color: white; 
            margin-bottom: 6px; 
            font-size: 1rem;
            font-weight: 700;
        }
        .forum-post .meta { 
            font-size: 0.72rem; 
            color: rgba(255,255,255,0.4);
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .forum-post .post-content { 
            margin-top: 10px; 
            margin-bottom: 12px;
            line-height: 1.6;
            color: rgba(255,255,255,0.8);
            font-size: 0.92rem;
        }
        .forum-post .delete-btn {
            position: absolute; top: 14px; right: 14px;
            background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239,68,68,0.4);
            color: #ef4444; padding: 4px 10px; border-radius: 5px;
            cursor: pointer; font-size: 0.68rem; font-weight: 700;
            transition: all 0.2s;
        }
        .forum-post .delete-btn:hover { background: rgba(239,68,68,0.3); border-color: #ef4444; }

        .comments-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.07);
        }
        .comments-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .comments-header span {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.45);
            font-weight: 500;
        }
        .toggle-comments {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 5px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .toggle-comments:hover { 
            border-color: rgba(255,255,255,0.35);
            color: white;
        }
        .comments-list {
            display: none;
            max-height: 250px;
            overflow-y: auto;
            margin-bottom: 10px;
            scroll-behavior: smooth;
        }
        .comments-list::-webkit-scrollbar { width: 3px; }
        .comments-list::-webkit-scrollbar-track { background: transparent; }
        .comments-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.12); border-radius: 3px; }
        .comments-list.visible { display: block; }
        .comment {
            background: rgba(255,255,255,0.04);
            padding: 10px 12px;
            border-radius: 7px;
            margin-bottom: 6px;
            position: relative;
            border: 1px solid rgba(255,255,255,0.06);
            transition: background 0.15s;
        }
        .comment:hover {
            background: rgba(255,255,255,0.07);
        }
        .comment.reply {
            margin-left: 24px;
            border-left: 2px solid rgba(255,255,255,0.1);
            border-radius: 0 7px 7px 0;
        }
        .comment .comment-author {
            font-weight: 700;
            color: rgba(255,255,255,0.85);
            font-size: 0.8rem;
        }
        .comment .comment-text {
            font-size: 0.88rem;
            margin-top: 4px;
            line-height: 1.5;
            color: rgba(255,255,255,0.7);
        }
        .comment .comment-date {
            font-size: 0.67rem;
            color: rgba(255,255,255,0.3);
            margin-top: 5px;
        }
        .comment .comment-actions {
            display: flex;
            gap: 6px;
            margin-top: 7px;
        }
        .comment .reply-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.5);
            padding: 3px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.67rem;
            font-weight: 600;
            transition: all 0.2s;
        }
        .comment .reply-btn:hover { 
            border-color: rgba(255,255,255,0.3);
            color: rgba(255,255,255,0.85);
        }
        .comment .delete-comment-btn {
            background: transparent;
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: rgba(239,68,68,0.7);
            padding: 3px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.67rem;
            font-weight: 600;
            transition: all 0.2s;
        }
        .comment .delete-comment-btn:hover { background: rgba(239,68,68,0.15); color: #ef4444; }
        .reply-form {
            display: none;
            margin-top: 8px;
            margin-left: 30px;
        }
        .reply-form.visible { 
            display: flex; 
            gap: 8px; 
            animation: slideDown 0.3s ease-out;
        }
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .reply-form input {
            flex: 1;
            margin-bottom: 0;
        }
        .reply-form button {
            padding: 8px 16px;
            font-size: 0.75rem;
        }
        .add-comment-form {
            display: none;
            margin-top: 12px;
        }
        .add-comment-form.visible { 
            display: flex; 
            gap: 10px;
        }
        .add-comment-form input {
            flex: 1;
            margin-bottom: 0;
        }
        .add-comment-form button {
            padding: 10px 16px;
            font-size: 0.8rem;
            font-weight: 700;
        }

        .login-required-msg {
            text-align: center;
            padding: 20px;
            color: rgba(255,255,255,0.6);
            font-style: italic;
        }
        .login-required-msg a {
            color: var(--primary);
            cursor: pointer;
        }

        #toast-container {
            position: absolute;
            top: 80px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; gap: 12px; pointer-events: none; z-index: 4000;
            align-items: center;
        }
        
        .toast {
            display: flex; align-items: center; gap: 12px;
            padding: 14px 24px; border-radius: 50px;
            font-weight: 700; font-size: 0.95rem;
            animation: toastIn 0.4s ease-out;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }
        
        .toast.success { background: linear-gradient(135deg, #10b981, #059669); color: white; }
        .toast.error { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; }
        .toast.info { background: linear-gradient(135deg, #00f2fe, #4facfe); color: #0f172a; }
        .toast.warning { background: linear-gradient(135deg, #f59e0b, #d97706); color: #0f172a; }
        .toast.power { background: linear-gradient(135deg, #a855f7, #8b5cf6); color: white; }
        .toast.omega { background: linear-gradient(135deg, #ffd700, #ff6b00); color: white; }
        .toast.admin { background: linear-gradient(135deg, #ff00ff, #00ffff); color: white; }
        .toast.kill { background: linear-gradient(135deg, #dc2626, #991b1b); color: white; }
        .toast.mythic { background: linear-gradient(135deg, #ff00cc, #3333ff); color: white; }
        #baby-controls {
            position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%);
            z-index: 6000; display: none;
            background: rgba(0,0,0,0.9); border: 2px solid #ff69b4;
            border-radius: 16px; padding: 14px 20px; text-align: center;
            box-shadow: 0 0 30px rgba(255,105,180,0.5);
        }
        #baby-controls.visible { display: block; }
        #baby-controls h4 { color: #ff69b4; font-size: 0.9rem; margin-bottom: 10px; letter-spacing: 1px; }
        .baby-hp-bar { width: 200px; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; margin: 0 auto 10px; }
        .baby-hp-fill { height: 100%; background: linear-gradient(90deg, #ff69b4, #ff1493); border-radius: 3px; transition: width 0.3s; }
        .baby-btn-row { display: flex; gap: 8px; justify-content: center; }
        .baby-btn { padding: 7px 14px; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 0.8rem; border: none; transition: all 0.2s; }
        .baby-btn.destruct { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; }
        .baby-btn.recall { background: linear-gradient(135deg, #10b981, #059669); color: white; }
        .baby-btn:hover { filter: brightness(1.2); transform: translateY(-1px); }
        
        .toast-exit { animation: toastOut 0.3s ease-in forwards; }
        @keyframes toastIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes toastOut { to { opacity: 0; transform: translateY(-10px); } }

        #damage-numbers { position: absolute; inset: 0; pointer-events: none; z-index: 100; }
        .dmg-num {
            position: absolute; font-weight: 900; font-size: 24px;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
            animation: floatUp 1s ease-out forwards; pointer-events: none;
        }
        .dmg-num.damage { color: #ef4444; }
        .dmg-num.heal { color: #10b981; }
        .dmg-num.crit { color: #f59e0b; font-size: 32px; }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-60px) scale(0.8); }
        }

        .power-type-badge {
            position: absolute; top: -8px; right: -8px;
            background: rgba(0,0,0,0.8); padding: 2px 8px; border-radius: 10px;
            font-size: 0.65rem; text-transform: uppercase; font-weight: bold;
        }
        .power-type-badge.omega { background: linear-gradient(135deg, #ffd700, #ff6b00); }

        #clone-timer {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            width: 150px; height: 8px; background: rgba(0,0,0,0.5);
            border-radius: 4px; overflow: hidden; display: none;
        }
        #clone-timer-fill { height: 100%; background: linear-gradient(90deg, #14b8a6, #10b981); }
        #clone-timer-label {
            position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%);
            font-size: 0.75rem; color: #14b8a6; font-weight: bold; display: none;
        }

        #death-screen {
            position: fixed; inset: 0; background: rgba(0,0,0,0.9);
            z-index: 5000; display: none; justify-content: center;
            align-items: center; flex-direction: column;
        }
        #death-screen.active { display: flex; animation: fadeIn 0.5s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .death-text {
            font-size: 5rem; font-weight: 900; color: #ef4444;
            text-shadow: 0 0 50px rgba(239, 68, 68, 0.5);
        }
        .respawn-timer { margin-top: 30px; font-size: 1.5rem; color: rgba(255,255,255,0.8); }

        #admin-panel {
            position: absolute; top: 70px; left: 20px;
            width: 280px; display: none; z-index: 2500;
            max-height: calc(100vh - 100px); overflow-y: auto;
        }
        #admin-panel.visible { display: block; }
        #admin-panel h3 { color: #ff00ff; margin-bottom: 15px; }
        .admin-section { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .admin-section-title { font-size: 0.8rem; text-transform: uppercase; color: rgba(255,255,255,0.5); margin-bottom: 8px; }
        .admin-btn {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 12px; border-radius: 8px; color: white; cursor: pointer;
            width: 100%; margin-bottom: 6px; transition: all 0.2s;
        }
        .admin-btn:hover { background: rgba(255,255,255,0.2); }
        .admin-btn.active { background: rgba(255,215,0,0.3); border-color: #ffd700; }
        .power-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
        .power-grid-btn {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 4px; border-radius: 8px; color: white; cursor: pointer;
            font-size: 0.7rem; display: flex; flex-direction: column; align-items: center;
        }
        .power-grid-btn:hover { transform: scale(1.05); }
        #admin-toggle {
            position: absolute; top: 20px; left: 20px; z-index: 2600; display: none;
            background: linear-gradient(135deg, #ff00ff, #00ffff);
            border: none; padding: 10px 15px; border-radius: 8px;
            color: white; font-weight: bold; cursor: pointer;
        }

        #game-announcement {
            position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
            z-index: 6000; display: none; text-align: center; pointer-events: none;
        }
        #game-announcement.visible { display: block; animation: announceFade 5s forwards; }
        .announce-text {
            font-size: 2rem; font-weight: 900;
            background: linear-gradient(135deg, #ff00ff, #00ffff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: none;
            padding: 10px 30px;
            border: 2px solid rgba(255, 0, 255, 0.5);
            border-radius: 16px;
            background-clip: text;
            backdrop-filter: blur(10px);
            background-color: rgba(0,0,0,0.7);
        }
        @keyframes announceFade {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            15% { opacity: 1; transform: translateX(-50%) translateY(0); }
            70% { opacity: 1; }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }

        #omega-unlock-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.9);
            z-index: 5000; display: none; justify-content: center;
            align-items: center; flex-direction: column;
        }
        #omega-unlock-overlay.active { display: flex; animation: omegaFlash 2s forwards; }
        @keyframes omegaFlash {
            0% { background: rgba(255,215,0,0.8); }
            100% { background: rgba(0,0,0,0); }
        }
        .omega-text {
            font-size: 3rem; font-weight: 900;
            background: linear-gradient(135deg, #ffd700, #ff6b00, #ff0080);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        .connecting-text { margin-top: 10px; color: rgba(255,255,255,0.6); }
        .connecting-text.active { animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }

        #screen-effects { position: fixed; inset: 0; pointer-events: none; z-index: 90; }
        .timestop-effect {
            position: absolute; inset: 0;
            background: radial-gradient(circle, transparent 30%, rgba(0,255,255,0.2) 100%);
            animation: effectPulse 0.5s infinite;
        }
        .mirror-effect {
            position: absolute; inset: 0;
            background: radial-gradient(circle, transparent 40%, rgba(192,192,192,0.15) 100%);
        }
        @keyframes effectPulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 0.8; } }

        /* Update panel on main menu */
        /* ‚îÄ‚îÄ Update Panel ‚îÄ‚îÄ */
        #update-panel {
            position: fixed; bottom: 24px; left: 24px;
            width: 258px; z-index: 101; pointer-events: auto;
            background: rgba(8,8,18,0.92);
            border: 1px solid rgba(0,242,254,0.14);
            border-radius: 14px; padding: 0;
            backdrop-filter: blur(14px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.05);
            overflow: hidden;
        }
        #update-panel.hidden { display: none; }
        #update-panel .up-header {
            display: flex; align-items: center; gap: 10px; padding: 12px 14px 10px;
            background: rgba(0,242,254,0.05);
            border-bottom: 1px solid rgba(0,242,254,0.1);
        }
        #update-panel .up-icon {
            width: 30px; height: 30px; border-radius: 8px; flex-shrink: 0;
            background: linear-gradient(135deg,rgba(0,242,254,0.3),rgba(79,172,254,0.2));
            display: flex; align-items: center; justify-content: center; font-size: 15px;
        }
        #update-panel .up-title { font-size: 0.75rem; font-weight: 800; letter-spacing: 0.8px; color: #00f2fe; text-transform: uppercase; }
        #update-panel .up-date { font-size: 0.58rem; color: rgba(255,255,255,0.3); margin-top: 1px; }
        #update-panel .up-body { padding: 10px 14px 12px; display: flex; flex-direction: column; gap: 7px; }
        .update-entry { display: flex; gap: 9px; align-items: flex-start; }
        .update-tag {
            font-size: 0.5rem; font-weight: 900; text-transform: uppercase; letter-spacing: 0.3px;
            padding: 2px 6px; border-radius: 5px; white-space: nowrap; margin-top: 2px; flex-shrink: 0;
        }
        .update-tag.new { background: rgba(16,185,129,0.12); color: #34d399; border: 1px solid rgba(16,185,129,0.28); }
        .update-tag.fix { background: rgba(239,68,68,0.1); color: #f87171; border: 1px solid rgba(239,68,68,0.22); }
        .update-tag.change { background: rgba(79,172,254,0.1); color: #60b4fe; border: 1px solid rgba(79,172,254,0.22); }
        .update-desc { font-size: 0.69rem; color: rgba(255,255,255,0.5); line-height: 1.45; }
        /* ‚îÄ‚îÄ Emote System ‚îÄ‚îÄ */
        #emote-wheel {
            position: fixed; right: 66px; top: 50%; transform: translateY(-50%);
            display: none; z-index: 300; pointer-events: auto; flex-direction: column; gap: 8px;
        }
        #emote-wheel.visible { display: flex; }
        .emote-btn-ingame {
            width: 52px; height: 52px; border-radius: 50%;
            background: rgba(8,8,18,0.94); border: 2px solid rgba(0,242,254,0.35);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.15s; backdrop-filter: blur(8px); box-shadow: 0 4px 16px rgba(0,0,0,0.5);
            padding: 0;
        }
        .emote-btn-ingame:hover { transform: scale(1.2); border-color: #00f2fe; }
        #emote-toggle-btn {
            position: fixed; right: 12px; top: 50%; transform: translateY(-50%);
            width: 40px; height: 40px; border-radius: 50%;
            background: rgba(8,8,18,0.9); border: 2px solid rgba(0,242,254,0.28);
            font-size: 18px; cursor: pointer; display: none; align-items: center; justify-content: center;
            z-index: 301; transition: all 0.2s; pointer-events: auto;
        }
        #emote-toggle-btn.ingame { display: flex; }
        #emote-toggle-btn:hover { transform: translateY(-50%) scale(1.12); border-color: #00f2fe; }
        #emote-hint { position: fixed; right: 8px; bottom: 225px; font-size: 0.58rem; color: rgba(255,255,255,0.28); text-align: center; pointer-events: none; display: none; width: 56px; }
        #emote-hint.ingame { display: block; }
        /* Emote shop in main menu */
        #emote-shop-modal .emote-grid { display: grid; grid-template-columns: repeat(4,1fr); gap: 10px; margin-top: 14px; }
        .emote-shop-item {
            background: rgba(255,255,255,0.03); border: 2px solid rgba(255,255,255,0.08);
            border-radius: 12px; padding: 14px 6px; text-align: center; cursor: pointer; transition: all 0.18s;
        }
        .emote-shop-item:hover { background: rgba(0,242,254,0.07); border-color: rgba(0,242,254,0.35); }
        .emote-shop-item.equipped { border-color: #00f2fe; background: rgba(0,242,254,0.1); }
        .emote-shop-item .emote-icon { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; margin: 0 auto 5px; }
        .emote-shop-item .emote-name { font-size: 0.62rem; color: rgba(255,255,255,0.55); font-weight: 600; }
        .emote-shop-item .emote-badge { font-size: 0.5rem; padding: 1px 5px; border-radius: 4px; display: inline-block; margin-top: 4px; font-weight: 800; background: rgba(16,185,129,0.12); color: #34d399; border: 1px solid rgba(16,185,129,0.28); }
        .equipped-slots { display: flex; gap: 8px; margin: 14px 0 4px; }
        .equipped-slot { flex: 1; text-align: center; padding: 8px 4px; background: rgba(255,255,255,0.03); border-radius: 8px; border: 1px dashed rgba(255,255,255,0.1); }
        .equipped-slot .emote-icon { width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; margin: 0 auto; }
        .equipped-slot .slot-key { font-size: 0.55rem; color: rgba(255,255,255,0.3); margin-top: 2px; }
        /* NPC announce toast */
        #npc-announce {
            position: fixed; bottom: 265px; left: 50%; transform: translateX(-50%);
            padding: 6px 18px; border-radius: 16px; font-size: 0.78rem; font-weight: 700;
            pointer-events: none; z-index: 200; opacity: 0; transition: opacity 0.3s; white-space: nowrap;
            background: rgba(8,8,18,0.9); border: 1px solid rgba(245,158,11,0.4); color: #fbbf24;
        }
        #npc-announce.visible { opacity: 1; }

        /* Forum guest notice */
        #forum-guest-notice {
            font-size: 0.8rem; color: rgba(255,255,255,0.5);
            text-align: center; padding: 8px 0 12px;
        }
        #forum-guest-notice a { color: var(--primary); cursor: pointer; }
        #forum-guest-notice a:hover { text-decoration: underline; }

        /* Inventory slots */
        #inventory-slots { display: flex; gap: 10px; align-items: center; }
        .inv-slot {
            width: 80px; height: 80px;
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            position: relative; transition: all 0.3s; cursor: pointer;
        }
        .inv-slot.active-slot {
            border-color: var(--primary);
            box-shadow: 0 0 30px rgba(0, 242, 254, 0.4);
            background: rgba(0, 242, 254, 0.1);
        }
        .inv-slot.locked-slot {
            opacity: 0.35;
            border-style: dashed;
            border-color: rgba(255,255,255,0.2);
            pointer-events: none;
        }
        .inv-slot.speed-active { animation: speedPulse 0.5s infinite; }
        .inv-slot.omega-active { animation: omegaPulse 0.5s infinite; border-color: #ffd700; }
        .slot-num {
            position: absolute; top: 4px; left: 8px;
            font-size: 0.65rem; font-weight: 900;
            color: rgba(255,255,255,0.5);
        }
        .slot-lock-icon {
            font-size: 1.2rem; color: rgba(255,255,255,0.3);
        }
        .inv-slot .power-type-badge {
            position: absolute; top: -7px; right: -6px;
            background: rgba(0,0,0,0.85); padding: 1px 5px; border-radius: 8px;
            font-size: 0.5rem; text-transform: uppercase; font-weight: bold;
            letter-spacing: 0.2px; white-space: nowrap;
        }
        .inv-slot .power-type-badge.omega { background: linear-gradient(135deg, #ffd700, #ff6b00); }
        .inv-slot-hint {
            font-size: 0.62rem; color: rgba(255,255,255,0.55); font-weight: bold;
            margin-top: 3px; text-align: center; max-width: 74px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }

        /* Cooldown overlay on slot */
        .slot-cooldown-overlay {
            position: absolute; inset: 0; border-radius: 18px;
            background: rgba(0,0,0,0.65);
            display: none; justify-content: center; align-items: center;
            flex-direction: column; pointer-events: none;
        }
        .slot-cooldown-overlay.active { display: flex; }
        .slot-cooldown-text {
            font-size: 1.3rem; font-weight: 900; color: white;
            text-shadow: 0 0 8px rgba(0,242,254,0.8);
        }

        /* Stamina depleted notification */
        #stamina-notif {
            position: fixed; bottom: 198px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.75); border: 1px solid rgba(180,180,180,0.4);
            color: rgba(200,200,200,0.9); padding: 5px 16px;
            border-radius: 20px; font-size: 0.8rem; font-weight: 700;
            pointer-events: none; z-index: 200;
            opacity: 0; transition: opacity 0.3s;
            letter-spacing: 0.5px;
        }
        #stamina-notif.visible { opacity: 1; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="screen-effects"></div>

    <div id="ui-layer">
        <div id="top-left-ui" class="pointer-events-auto">
            <button id="login-btn" class="btn-neon" onclick="openModal('login-modal')">Login / Sign Up</button>
            <div id="user-profile" style="display: none;">
                <div style="display:flex; flex-direction:column;">
                    <span style="font-size:0.8rem; color:rgba(255,255,255,0.6);">Logged in as</span>
                    <span id="profile-name" style="font-weight: bold; color:var(--primary);">User</span>
                </div>
                <button class="btn-text" onclick="signOut()" style="margin:0; margin-left:15px; font-size: 0.8rem; color: #ff0055;">Logout</button>
            </div>
        </div>

        <div id="top-right-ui" class="pointer-events-auto">
            <button class="btn-neon" onclick="openForum()">Forum</button>
            <button class="btn-neon" onclick="openModal('emote-shop-modal'); renderEmoteShop()" style="margin-left:8px;">Emotes</button>
        </div>

        <div id="main-menu" class="pointer-events-auto">
            <h1 class="logo">PowerSwap.io</h1>
            <div class="glass-panel menu-card">
                <input type="text" id="username-input" class="modern-input" placeholder="Enter Nickname" maxlength="12" style="text-align: center; font-size: 1.2rem;">
                <button id="play-btn" onclick="joinGame()" class="btn-neon" style="width: 100%; padding: 15px; font-size: 1.2rem;">Play Now</button>
                <div id="connecting-status" class="connecting-text" style="display: none;">Connecting...</div>
            </div>
            <div style="margin-top: 20px; color: rgba(255,255,255,0.5); font-size: 0.9rem;">
                Mouse to Move | SPACE to Use Power | D to Drop
            </div>
            <div style="margin-top: 10px; color: rgba(255,215,0,0.7); font-size: 0.85rem;">
                Get 10 kills to unlock OMEGA powers! Press Q to activate
            </div>
        </div>

        <div id="update-panel">
            <div class="up-header">
                <div class="up-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="8" height="4" rx="1" fill="#00f2fe"/><rect x="4" y="4" width="16" height="18" rx="2" stroke="#00f2fe" stroke-width="2" fill="none"/><line x1="8" y1="10" x2="16" y2="10" stroke="#00f2fe" stroke-width="1.5" stroke-linecap="round"/><line x1="8" y1="14" x2="16" y2="14" stroke="#00f2fe" stroke-width="1.5" stroke-linecap="round"/><line x1="8" y1="18" x2="13" y2="18" stroke="#00f2fe" stroke-width="1.5" stroke-linecap="round"/></svg></div>
                <div>
                    <div class="up-title">Latest Updates</div>
                    <div class="up-date">Feb 2026 patch</div>
                </div>
            </div>
            <div class="up-body">
                <div class="update-entry">
                    <span class="update-tag new">New</span>
                    <span class="update-desc">NPCs ‚Äî Common to Mythic, unique drops &amp; behavior</span>
                </div>
                <div class="update-entry">
                    <span class="update-tag new">New</span>
                    <span class="update-desc">Emotes ‚Äî pick 4, use in-game with E key</span>
                </div>
                <div class="update-entry">
                    <span class="update-tag new">New</span>
                    <span class="update-desc">3-slot inventory ‚Äî unlocks at 5 kills per life</span>
                </div>
                <div class="update-entry">
                    <span class="update-tag new">New</span>
                    <span class="update-desc">Sprint (Shift) ‚Äî stamina drain &amp; regen</span>
                </div>
                <div class="update-entry">
                    <span class="update-tag change">Change</span>
                    <span class="update-desc">Sniper 6s ¬∑ Minigun 0.2s ¬∑ Others 1.5s cooldown</span>
                </div>
                <div class="update-entry">
                    <span class="update-tag fix">Fix</span>
                    <span class="update-desc">Forum visible to all ‚Äî no login required</span>
                </div>
            </div>
        </div>

        <button id="admin-toggle" class="pointer-events-auto" onclick="toggleAdminPanel()">OWNER</button>

        <div id="admin-panel" class="glass-panel pointer-events-auto">
            <h3>Owner Panel</h3>
            <div class="admin-section">
                <div class="admin-section-title">Quick Actions</div>
                <button class="admin-btn" onclick="adminAction('heal')">Full Heal Self</button>
                <button class="admin-btn" onclick="adminAction('kill_all')">Kill All Players</button>
                <button class="admin-btn" onclick="adminAction('teleport_center')">Teleport Center</button>
                <button class="admin-btn" onclick="adminAction('add_kills')">+10 Kills</button>
                <button class="admin-btn" onclick="adminAction('heal_all')">Heal All Players</button>
                <button class="admin-btn" onclick="adminAction('clear_powerups')">Clear All Powerups</button>
                <button class="admin-btn" onclick="adminAction('respawn_all')">Respawn All</button>
                <button class="admin-btn" onclick="adminSpawnBoss()" style="background:rgba(220,38,38,0.3);border-color:#dc2626;">‚ö†Ô∏è Force Spawn Boss</button>
            </div>
            <div class="admin-section">
                <div class="admin-section-title">Toggles</div>
                <button class="admin-btn" id="godmode-btn" onclick="adminAction('toggle_godmode')">God Mode: OFF</button>
                <button class="admin-btn" id="infinite-btn" onclick="adminAction('toggle_infinite')">Infinite Power: OFF</button>
            </div>
            <div class="admin-section">
                <div class="admin-section-title">UNRELEASED ADMIN POWERS</div>
                <div class="power-grid" id="admin-omega-grid"></div>
            </div>
            <div class="admin-section">
                <div class="admin-section-title">All Regular Powers</div>
                <div class="power-grid" id="admin-powers-grid"></div>
            </div>
            <div class="admin-section">
                <div class="admin-section-title">üì¢ Announce In-Game</div>
                <textarea id="announce-text" class="modern-input" placeholder="Type announcement..." style="height: 60px; resize: none;"></textarea>
                <button class="admin-btn" style="background: rgba(255,0,255,0.2); border-color: #ff00ff;" onclick="sendAnnouncement()">üì¢ Broadcast to All</button>
            </div>
            <div class="admin-section">
                <div class="admin-section-title">Spawn Powerup</div>
                <select id="spawn-power-select" class="modern-input"></select>
                <button class="admin-btn" onclick="adminAction('spawn_power')">Spawn at Cursor</button>
            </div>
        </div>

        <div id="hud-bottom">
            <div id="inventory-slots">
                <div class="inv-slot glass-panel active-slot" id="inv-slot-0" onclick="selectSlot(0)">
                    <span class="slot-num">1</span>
                    <canvas id="inv-canvas-0" width="44" height="44"></canvas>
                    <span class="power-type-badge" id="inv-badge-0" style="display:none;"></span>
                    <div class="slot-cooldown-overlay" id="inv-cd-0">
                        <span class="slot-cooldown-text" id="inv-cd-text-0"></span>
                    </div>
                    <div class="inv-slot-hint" id="inv-hint-0">No Power</div>
                </div>
                <div class="inv-slot glass-panel locked-slot" id="inv-slot-1" onclick="selectSlot(1)">
                    <span class="slot-num">2</span>
                    <div class="slot-lock-icon" id="inv-lock-1"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="5" y="11" width="14" height="10" rx="2" fill="rgba(255,255,255,0.25)"/><path d="M8 11V7a4 4 0 0 1 8 0v4" stroke="rgba(255,255,255,0.4)" stroke-width="2" fill="none" stroke-linecap="round"/><circle cx="12" cy="16" r="1.5" fill="rgba(255,255,255,0.4)"/></svg></div>
                    <canvas id="inv-canvas-1" width="44" height="44" style="display:none;"></canvas>
                    <span class="power-type-badge" id="inv-badge-1" style="display:none;"></span>
                    <div class="slot-cooldown-overlay" id="inv-cd-1">
                        <span class="slot-cooldown-text" id="inv-cd-text-1"></span>
                    </div>
                    <div class="inv-slot-hint" id="inv-hint-1"></div>
                </div>
                <div class="inv-slot glass-panel locked-slot" id="inv-slot-2" onclick="selectSlot(2)">
                    <span class="slot-num">3</span>
                    <div class="slot-lock-icon" id="inv-lock-2"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="5" y="11" width="14" height="10" rx="2" fill="rgba(255,255,255,0.25)"/><path d="M8 11V7a4 4 0 0 1 8 0v4" stroke="rgba(255,255,255,0.4)" stroke-width="2" fill="none" stroke-linecap="round"/><circle cx="12" cy="16" r="1.5" fill="rgba(255,255,255,0.4)"/></svg></div>
                    <canvas id="inv-canvas-2" width="44" height="44" style="display:none;"></canvas>
                    <span class="power-type-badge" id="inv-badge-2" style="display:none;"></span>
                    <div class="slot-cooldown-overlay" id="inv-cd-2">
                        <span class="slot-cooldown-text" id="inv-cd-text-2"></span>
                    </div>
                    <div class="inv-slot-hint" id="inv-hint-2"></div>
                </div>
            </div>
            <div style="font-size:0.72rem; opacity:0.7; margin-top:4px; text-align:center;">1/2/3 Switch ¬∑ SPACE Use ¬∑ D Drop</div>
        </div>

        <div id="kill-counter">
            <span>Kills: <span id="kill-count">0</span>/<span id="kill-threshold">10</span></span>
            <span id="omega-ready" style="display:none; color: #ffd700; margin-left: 10px;"></span>
        </div>

        <div id="clone-timer-label">CLONE ACTIVE</div>
        <div id="clone-timer"><div id="clone-timer-fill"></div></div>

        <div id="leaderboard" class="glass-panel">
            <div class="lb-header">
                <span>Leaderboard</span>
                <span style="font-size:0.7rem; opacity:0.7;">Kills</span>
            </div>
            <div id="lb-content"><div class="lb-row"><span>Loading...</span></div></div>
        </div>

        <div id="chat-wrap" class="pointer-events-auto">
            <div id="chat-history"></div>
            <input type="text" id="chat-input" class="modern-input" placeholder="Type to chat..." maxlength="80" style="margin-bottom: 0;">
        </div>

        <div id="damage-numbers"></div>
    </div>

    <div id="game-announcement">
        <div class="announce-text" id="announce-message"></div>
    </div>

    <div id="death-screen">
        <div class="death-text">WASTED</div>
        <div class="respawn-timer">Respawning in <span id="respawn-countdown">3</span>...</div>
    </div>

    <div id="omega-unlock-overlay">
        <div class="omega-text">OMEGA UNLOCKED</div>
        <div id="omega-power-name" style="color: #ffd700; margin-top: 20px; font-size: 1.5rem; font-weight: bold;"></div>
        <div style="color: rgba(255,255,255,0.8); margin-top: 10px;">Press Q to activate!</div>
    </div>

    <div id="login-modal" class="modal-overlay pointer-events-auto">
        <div class="glass-panel modal-content">
            <span class="close-btn" onclick="closeModal('login-modal')">√ó</span>
            <h2 style="margin-bottom: 20px; text-align: center;">Welcome Back</h2>
            <input type="email" id="auth-email" class="modern-input" placeholder="Email Address">
            <input type="password" id="auth-pass" class="modern-input" placeholder="Password">
            <button class="btn-neon" style="width: 100%;" onclick="handleLogin()">Login</button>
            <button class="btn-text" style="width: 100%;" onclick="openModal('signup-modal'); closeModal('login-modal')">Create New Account</button>
        </div>
    </div>

    <div id="signup-modal" class="modal-overlay pointer-events-auto">
        <div class="glass-panel modal-content">
            <span class="close-btn" onclick="closeModal('signup-modal')">√ó</span>
            <h2 style="margin-bottom: 20px; text-align: center;">Create Account</h2>
            <input type="text" id="signup-username" class="modern-input" placeholder="Username" maxlength="15">
            <input type="email" id="signup-email" class="modern-input" placeholder="Email Address">
            <input type="password" id="signup-pass" class="modern-input" placeholder="Password (6+ chars)">
            <button class="btn-neon" style="width: 100%;" onclick="handleSignup()">Sign Up</button>
            <button class="btn-text" style="width: 100%;" onclick="openModal('login-modal'); closeModal('signup-modal')">Back to Login</button>
        </div>
    </div>

    <div id="forum-modal" class="modal-overlay pointer-events-auto">
        <div class="glass-panel modal-content" style="max-width: 600px;">
            <span class="close-btn" onclick="closeModal('forum-modal')">√ó</span>
            <h2 style="margin-bottom: 15px;">Community Forum</h2>
            
            <div id="forum-create-ui" style="border-bottom: 1px solid var(--glass-border); padding-bottom: 15px; display: none;">
                <input type="text" id="forum-title" class="modern-input" placeholder="Title">
                <textarea id="forum-desc" class="modern-input" placeholder="Message..." style="height: 80px;"></textarea>
                <button class="btn-neon" onclick="createPost()">Post Message</button>
            </div>
            
            <div id="forum-guest-notice" style="display:none; text-align:center; padding: 8px 0 12px; font-size:0.82rem; color:rgba(255,255,255,0.5);">
                <a onclick="closeModal('forum-modal'); openModal('login-modal')" style="color:var(--primary); cursor:pointer;">Login</a> or <a onclick="closeModal('forum-modal'); openModal('signup-modal')" style="color:var(--primary); cursor:pointer;">sign up</a> to post &amp; comment.
            </div>
            
            <div id="forum-posts"></div>
        </div>
    </div>
    <div id="baby-controls" class="pointer-events-auto">
        <h4><svg width="14" height="14" viewBox="0 0 24 24" fill="#ff69b4" style="vertical-align:middle;margin-right:4px;"><circle cx="12" cy="8" r="5"/><path d="M4 20c0-4 3.58-7 8-7s8 3 8 7" fill="#ff69b4"/></svg> BABY CONTROLS</h4>
        <div style="font-size:0.75rem; color:rgba(255,255,255,0.6); margin-bottom:8px;">Baby moves toward your mouse. HP: <span id="baby-hp-text">50</span>/50</div>
        <div class="baby-hp-bar"><div class="baby-hp-fill" id="baby-hp-fill" style="width:100%"></div></div>
        <div class="baby-btn-row">
            <button class="baby-btn recall" onclick="recallBaby()">‚Ü© Return</button>
            <button class="baby-btn destruct" onclick="destructBaby()"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="vertical-align:middle;margin-right:3px;"><circle cx="12" cy="12" r="9" fill="#ef4444"/><path d="M8 8 L16 16 M16 8 L8 16" stroke="white" stroke-width="2.5" stroke-linecap="round"/></svg> Self-Destruct</button>
        </div>
    </div>
            <div id="toast-container"></div>

    <div id="stamina-notif">Stamina Depleted</div>
    <div id="npc-announce"></div>
    <button id="emote-toggle-btn" onclick="toggleEmoteWheel()" title="Emotes (E)"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="#00f2fe" stroke-width="2" fill="rgba(0,242,254,0.15)" stroke-linejoin="round"/><circle cx="9" cy="10" r="1.2" fill="#00f2fe"/><circle cx="15" cy="10" r="1.2" fill="#00f2fe"/><path d="M8 13 Q12 16 16 13" stroke="#00f2fe" stroke-width="1.5" stroke-linecap="round" fill="none"/></svg></button>
    <div id="emote-hint">E key</div>
    <div id="emote-wheel">
        <button class="emote-btn-ingame" id="emote-slot-0" onclick="useEmote(0)"></button>
        <button class="emote-btn-ingame" id="emote-slot-1" onclick="useEmote(1)"></button>
        <button class="emote-btn-ingame" id="emote-slot-2" onclick="useEmote(2)"></button>
        <button class="emote-btn-ingame" id="emote-slot-3" onclick="useEmote(3)"></button>
    </div>
    <div id="emote-shop-modal" class="modal-overlay pointer-events-auto">
        <div class="glass-panel modal-content" style="max-width:500px;">
            <span class="close-btn" onclick="closeModal('emote-shop-modal')">&#xd7;</span>
            <h2 style="margin-bottom:6px; display:flex; align-items:center; gap:8px;"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="#00f2fe" stroke-width="2" fill="rgba(0,242,254,0.15)"/><circle cx="9" cy="10" r="1.2" fill="#00f2fe"/><circle cx="15" cy="10" r="1.2" fill="#00f2fe"/><path d="M8 13 Q12 16 16 13" stroke="#00f2fe" stroke-width="1.5" stroke-linecap="round" fill="none"/></svg> Emote Collection</h2>
            <p style="font-size:0.78rem;color:rgba(255,255,255,0.45);margin-bottom:4px;">All 8 emotes are free! Click to equip up to 4.</p>
            <div class="equipped-slots" id="equipped-slots-display">
                <div class="equipped-slot"><span class="emote-icon" id="eq-slot-0">‚Äî</span><div class="slot-key">Slot 1</div></div>
                <div class="equipped-slot"><span class="emote-icon" id="eq-slot-1">‚Äî</span><div class="slot-key">Slot 2</div></div>
                <div class="equipped-slot"><span class="emote-icon" id="eq-slot-2">‚Äî</span><div class="slot-key">Slot 3</div></div>
                <div class="equipped-slot"><span class="emote-icon" id="eq-slot-3">‚Äî</span><div class="slot-key">Slot 4</div></div>
            </div>
            <div class="emote-grid" id="emote-shop-grid"></div>
        </div>
    </div>

    <script>
        const CONFIG = {
            colors: { primary: '#00f2fe', grid: '#1e293b', gridLine: '#334155' },
            map: { width: 4000, height: 4000 },
            serverUrl: 'https://skyfight-server.onrender.com',
            adminEmail: 'redadarwichepaypal@gmail.com',
            killsForOmega: 10
        };

        const POWERS = {
            dash: { color: '#f59e0b', name: 'Dash', type: 'instant', rarity: 'common' },
            teleport: { color: '#10b981', name: 'Warp', type: 'instant', rarity: 'rare' },
            clone: { color: '#14b8a6', name: 'Clone', type: 'instant', rarity: 'epic' },
            blackhole: { color: '#1e1b4b', name: 'Blackhole', type: 'instant', rarity: 'legendary' },
            nuke: { color: '#dc2626', name: 'Nuke', type: 'instant', rarity: 'legendary' },
            heal: { color: '#22c55e', name: 'Heal', type: 'instant', rarity: 'common' },
            emp: { color: '#6366f1', name: 'EMP', type: 'instant', rarity: 'rare' },
            swap: { color: '#ec4899', name: 'Swap', type: 'instant', rarity: 'epic' },
            shockwave: { color: '#8b5cf6', name: 'Shockwave', type: 'instant', rarity: 'rare' },
            speed: { color: '#ef4444', name: 'Speed', type: 'toggle', rarity: 'common' },
            phase: { color: '#a78bfa', name: 'Phase', type: 'toggle', rarity: 'epic' },
            berserker: { color: '#dc2626', name: 'Berserker', type: 'toggle', rarity: 'rare' },
            shield: { color: '#3b82f6', name: 'Shield', type: 'passive', rarity: 'common' },
            vampire: { color: '#7f1d1d', name: 'Vampire', type: 'passive', rarity: 'epic' },
            rage: { color: '#b91c1c', name: 'Rage', type: 'passive', rarity: 'rare' },
            tank: { color: '#374151', name: 'Tank', type: 'passive', rarity: 'rare' },
            magnet: { color: '#f97316', name: 'Magnet', type: 'passive', rarity: 'common' },
            thorns: { color: '#65a30d', name: 'Thorns', type: 'passive', rarity: 'rare' },
            regeneration: { color: '#34d399', name: 'Regen', type: 'passive', rarity: 'rare' },
            tripleshot: { color: '#a855f7', name: 'Triple', type: 'shoot', rarity: 'common' },
            laser: { color: '#ef4444', name: 'Laser', type: 'instant', rarity: 'rare' },
            rocket: { color: '#fb923c', name: 'Rocket', type: 'instant', rarity: 'epic' },
            scatter: { color: '#fbbf24', name: 'Scatter', type: 'shoot', rarity: 'rare' },
            sniper: { color: '#0ea5e9', name: 'Sniper', type: 'shoot', rarity: 'epic' },
            minigun: { color: '#78716c', name: 'Minigun', type: 'shoot', rarity: 'rare' },
            explosive: { color: '#f87171', name: 'Explosive', type: 'shoot', rarity: 'epic' },
            freeze: { color: '#0ea5e9', name: 'Freeze', type: 'shoot', rarity: 'rare' },
            poison: { color: '#84cc16', name: 'Poison', type: 'instant', rarity: 'rare' },
            lightning: { color: '#facc15', name: 'Lightning', type: 'instant', rarity: 'epic' },
            // COOL POWERS
            timebomb: { color: '#ff6b00', name: 'Time Bomb', type: 'instant', rarity: 'epic' },
            orbitallaser: { color: '#00f5ff', name: 'Orbital Laser', type: 'instant', rarity: 'legendary' },
            shadowclone: { color: '#1a1a2e', name: 'Shadow Clone', type: 'instant', rarity: 'epic' },
            frostnova: { color: '#a5f3fc', name: 'Frost Nova', type: 'instant', rarity: 'legendary' },
            soulrip: { color: '#7c00ff', name: 'Soul Rip', type: 'instant', rarity: 'legendary' },
            voidbeam: { color: '#5b21b6', name: 'Void Beam', type: 'shoot', rarity: 'legendary' },
            // FUNCTIONAL POWERS
            gravitypull: { color: '#7c3aed', name: 'Gravity Pull', type: 'instant', rarity: 'epic' },
            mirror: { color: '#c0c0c0', name: 'Mirror Shield', type: 'instant', rarity: 'epic' },
            chaos: { color: '#ec4899', name: 'Chaos Orb', type: 'instant', rarity: 'legendary' },
            baby: { color: '#ff69b4', name: 'Baby', type: 'instant', rarity: 'mythic' },
            phoenix: { color: '#ff6600', name: 'Phoenix', type: 'passive', rarity: 'mythic' },
            soulsteal: { color: '#8800ff', name: 'Soul Steal', type: 'instant', rarity: 'mythic' }
        };

        // Single Omega power - first to 10 kills gets this
        const OMEGA_POWER = {
            meteor: { color: '#ff4500', name: 'METEOR STRIKE', type: 'omega', rarity: 'omega' }
        };

        // Admin-only unreleased powers - ACTUALLY INSANE
        const ADMIN_POWERS = {
            apocalypse: { color: '#ff0000', name: 'APOCALYPSE', type: 'admin', rarity: 'admin' },
            chronobreak: { color: '#00ffff', name: 'CHRONO BREAK', type: 'admin', rarity: 'admin' },
            voidrift: { color: '#9333ea', name: 'VOID RIFT', type: 'admin', rarity: 'admin' },
            armageddon: { color: '#fbbf24', name: 'ARMAGEDDON', type: 'admin', rarity: 'admin' },
            omegabeam: { color: '#06b6d4', name: 'OMEGA BEAM', type: 'admin', rarity: 'admin' },
            singularity: { color: '#a855f7', name: 'SINGULARITY', type: 'admin', rarity: 'admin' },
            realitybomb: { color: '#ec4899', name: 'REALITY BOMB', type: 'admin', rarity: 'admin' },
            godmode: { color: '#ffd700', name: 'GOD MODE', type: 'admin', rarity: 'admin' },
            obliterate: { color: '#dc2626', name: 'OBLITERATE', type: 'admin', rarity: 'admin' },
            dimensionrift: { color: '#8b00ff', name: 'DIMENSION RIFT', type: 'admin', rarity: 'admin' },
            cosmicstorm: { color: '#ff1493', name: 'COSMIC STORM', type: 'admin', rarity: 'admin' },
            infinityvoid: { color: '#000066', name: 'INFINITY VOID', type: 'admin', rarity: 'admin' },
            starforge: { color: '#ffdf00', name: 'STAR FORGE', type: 'admin', rarity: 'admin' },
            quantumcollapse: { color: '#00fff7', name: 'QUANTUM COLLAPSE', type: 'admin', rarity: 'admin' },
            worldender: { color: '#b91c1c', name: 'WORLD ENDER', type: 'admin', rarity: 'admin' },
            divinebeam: { color: '#f0abfc', name: 'DIVINE BEAM', type: 'admin', rarity: 'admin' },
            blacksun: { color: '#1c1c1c', name: 'BLACK SUN', type: 'admin', rarity: 'admin' },
            stormcall: { color: '#60a5fa', name: 'STORM CALL', type: 'admin', rarity: 'admin' }
        };

        const RARITY_COLORS = { common: '#9ca3af', rare: '#3b82f6', epic: '#a855f7', legendary: '#f59e0b', omega: '#ffd700', admin: '#ff00ff', mythic: '#ff00cc' };
        const ALL_POWERS = { ...POWERS, ...OMEGA_POWER, ...ADMIN_POWERS };

        const EMOTE_CATALOG = [
            { key: 'laugh',  name: 'Laughing'  },
            { key: 'heart',  name: 'Heart'      },
            { key: 'cry',    name: 'Crying'     },
            { key: 'fire',   name: 'Fire'       },
            { key: 'rage',   name: 'Rage'       }
        ];

        // Custom SVG emote strings (used in DOM)
        const EMOTE_SVG_STRS = {
            laugh: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36" width="28" height="28"><circle cx="18" cy="18" r="17" fill="#FFD93D"/><path d="M9 21 Q18 30 27 21" fill="none" stroke="#333" stroke-width="2.5" stroke-linecap="round"/><path d="M9 21 Q18 31 27 21 Z" fill="#8B2020"/><circle cx="13" cy="14" r="2.5" fill="#333"/><circle cx="23" cy="14" r="2.5" fill="#333"/><path d="M11 13 Q13 10 15 13" fill="none" stroke="#333" stroke-width="1.5"/><path d="M21 13 Q23 10 25 13" fill="none" stroke="#333" stroke-width="1.5"/><ellipse cx="7" cy="16" rx="2" ry="3" fill="#9DD4F8" opacity="0.8"/><ellipse cx="29" cy="16" rx="2" ry="3" fill="#9DD4F8" opacity="0.8"/></svg>`,
            heart: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36" width="28" height="28"><path d="M18 30 L5 17 C2 14 2 9 5 7 C7 5 11 5 13 8 L18 13 L23 8 C25 5 29 5 31 7 C34 9 34 14 31 17 Z" fill="#FF3860"/><path d="M11 8 Q8 7 7 10" fill="none" stroke="rgba(255,255,255,0.5)" stroke-width="2" stroke-linecap="round"/></svg>`,
            thumbs: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36" width="28" height="28"><rect x="5" y="20" width="8" height="12" rx="2" fill="#4A90D9"/><path d="M13 22 L19 14 Q21 10 24 10 L27 10 Q29 10 29 12 L29 13 Q31 13 31 15 L31 16 Q33 16 33 18 L33 19 Q33 21 31 21 L18 21 Q17 25 16 27 L14 27 Z" fill="#4A90D9"/><path d="M19 14 Q21 11 24 11" fill="none" stroke="rgba(255,255,255,0.4)" stroke-width="1.5" stroke-linecap="round"/></svg>`,
            cry:   `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36" width="28" height="28"><circle cx="18" cy="17" r="15" fill="#85C1E9"/><path d="M11 22 Q18 18 25 22" fill="none" stroke="#333" stroke-width="2.5" stroke-linecap="round"/><circle cx="13" cy="14" r="2.5" fill="#333"/><circle cx="23" cy="14" r="2.5" fill="#333"/><path d="M10 12 Q13 10 15 12" fill="none" stroke="#333" stroke-width="1.5"/><path d="M21 12 Q23 10 26 12" fill="none" stroke="#333" stroke-width="1.5"/><path d="M13 17 Q12 22 11 27 Q13 28 14 23 Z" fill="#4A90D9"/><path d="M23 17 Q24 22 25 27 Q23 28 22 23 Z" fill="#4A90D9"/></svg>`,
            fire:  `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36" width="28" height="28"><path d="M18 2 Q14 10 16 14 Q12 10 14 5 Q8 12 8 20 C8 27 12.5 34 18 34 C23.5 34 28 27 28 20 C28 14 24 8 18 2Z" fill="#FF6B2B"/><path d="M18 14 Q16 18 17 21 Q14 18 15 14 Q12 18 12 22 C12 26 14.7 30 18 30 C21.3 30 24 26 24 22 C24 18 21 15 18 14Z" fill="#FFD93D"/><circle cx="18" cy="25" r="4" fill="#FF4500" opacity="0.6"/></svg>`,
            skull: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36" width="28" height="28"><ellipse cx="18" cy="16" rx="13" ry="14" fill="#EAECEE"/><rect x="11" y="28" width="4" height="5" rx="1" fill="#EAECEE"/><rect x="17" y="28" width="4" height="5" rx="1" fill="#EAECEE"/><rect x="23" y="28" width="2" height="5" rx="1" fill="#EAECEE"/><ellipse cx="13" cy="15" rx="4" ry="4.5" fill="#1a1a2e"/><ellipse cx="23" cy="15" rx="4" ry="4.5" fill="#1a1a2e"/><path d="M13 20 L15 22 L13 24 M23 20 L21 22 L23 24" fill="none" stroke="#EAECEE" stroke-width="1.5" stroke-linecap="round"/><rect x="9" y="27" width="18" height="6" rx="2" fill="#BDC3C7"/></svg>`,
            cool:  `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36" width="28" height="28"><circle cx="18" cy="18" r="17" fill="#FFD93D"/><path d="M9 24 Q18 29 27 24" fill="none" stroke="#333" stroke-width="2.5" stroke-linecap="round"/><rect x="7" y="12" width="9" height="6" rx="3" fill="#1a1a2e"/><rect x="20" y="12" width="9" height="6" rx="3" fill="#1a1a2e"/><rect x="16" y="14" width="4" height="2" fill="#333"/><path d="M8 13 Q10 10 14 12" fill="none" stroke="#1a1a2e" stroke-width="1.5"/><path d="M22 12 Q26 10 28 13" fill="none" stroke="#1a1a2e" stroke-width="1.5"/></svg>`,
            rage:  `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36" width="28" height="28"><circle cx="18" cy="18" r="17" fill="#E74C3C"/><path d="M10 24 Q14 21 18 23 Q22 21 26 24" fill="none" stroke="#333" stroke-width="2.5" stroke-linecap="round"/><circle cx="13" cy="17" r="2.5" fill="#333"/><circle cx="23" cy="17" r="2.5" fill="#333"/><path d="M9 13 L15 15" stroke="#333" stroke-width="2.5" stroke-linecap="round"/><path d="M27 13 L21 15" stroke="#333" stroke-width="2.5" stroke-linecap="round"/><path d="M13 25 L15 25 L15 27 L17 27 L17 25 L19 25 L19 27 L21 27 L21 25 L23 25" fill="none" stroke="#8B0000" stroke-width="1.5"/></svg>`
        };

        // Preload emote images for canvas rendering
        const EMOTE_IMGS = {};
        (function preloadEmotes() {
            Object.entries(EMOTE_SVG_STRS).forEach(([key, svg]) => {
                const img = new Image();
                img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
                EMOTE_IMGS[key] = img;
            });
        })();
        const NPC_COLORS = { common:'#9ca3af', rare:'#3b82f6', epic:'#a855f7', legendary:'#f59e0b', mythic:'#ff00cc' };
        const NPC_RADII  = { common:18, rare:20, epic:23, legendary:27, mythic:32 };
        let sbClient = null, currentUser = null, dbUsername = '', isAdmin = false;
        let socket = null, myId = null, isConnecting = false, connectionAttempts = 0;
        let powerupIdCounter = 10000, projectileIdCounter = 50000;

        const state = {
            me: null, players: {}, projectiles: {}, powerups: {}, particles: [], clones: [],
            explosions: [], meteors: [], remoteClones: {}, camera: { x: 0, y: 0 },
            mouse: { x: 0, y: 0, worldX: 0, worldY: 0 }, running: false, lastTime: 0,
            speedActive: false, phaseActive: false, berserkerActive: false, shootCooldown: 0,
            cloneTimer: 0, cloneMaxTime: 12, kills: 0, omegaUnlocked: false, omegaPower: null,
            omegaTimer: 0, adminGodMode: false, adminInfinite: false,
            mirrorActive: false, timestopActive: false, hitCooldowns: {}, isDead: false, respawnTimer: 0, spawnProtection: 0,
            nextOmegaThreshold: 10,
            baby: null, babyShootCooldown: 0, remoteBabies: {}, babyBroadcastTimer: 0,
            laserBeams: [], rocketTrails: [], timebombs: [],
            bosses: {},
            npcs: {},
            equippedEmotes: ["laugh","heart","cry","fire"],
            activeEmoteBubbles: {},
            emoteWheelOpen: false,
            // Inventory system
            inventory: [null, null, null],
            activeSlot: 0,
            inventorySlots: 1,     // 1 until 5 kills, then 3; resets on death
            killsThisLife: 0,       // kills since last respawn
            slotCooldowns: [0, 0, 0], // cooldown remaining per slot
            // Sprint system
            sprinting: false,
            stamina: 100,
            staminaDepleted: false,
            staminaDepletedTimer: 0
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const SUPABASE_URL = 'https://jppfsqkshcmwskcdsqis.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpwcGZzcWtzaGNtd3NrY2RzcWlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA5MjczMzgsImV4cCI6MjA4NjUwMzMzOH0.ACkiOnXuKGnzKTqi2HSLggktIzrRWOFLje-dp20dpqU';

        function initSupabase() {
            if (typeof window.supabase !== 'undefined') {
                sbClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                checkSession();
            }
            initAdminPanel();
        }

        async function checkSession() {
            if (!sbClient) return;
            try {
                const { data } = await sbClient.auth.getSession();
                if (data.session) {
                    currentUser = data.session.user;
                    await fetchProfile();
                    checkAdminStatus();
                }
            } catch(e) { console.error('Session error:', e); }
            updateAuthUI();
            updateForumUI();
        }

       async function fetchProfile() {
            if (!currentUser || !sbClient) return;
            try {
                // 1. Try fetching from the profiles table
                const { data, error } = await sbClient
                    .from('profiles')
                    .select('username')
                    .eq('id', currentUser.id)
                    .single();
                
                // 2. Priority: Use Database name, fallback to Auth Metadata
                if (data && data.username) {
                    dbUsername = data.username;
                } else if (currentUser.user_metadata && currentUser.user_metadata.username) {
                    dbUsername = currentUser.user_metadata.username;
                }
            } catch(e) { 
                console.error('Profile fetch error:', e); 
            }
            // Update the UI immediately after fetching
            updateAuthUI();
        }

        function checkAdminStatus() {
            isAdmin = currentUser && currentUser.email === CONFIG.adminEmail;
            const toggle = document.getElementById('admin-toggle');
            if(toggle) toggle.style.display = isAdmin ? 'block' : 'none';
        }

        function updateAuthUI() {
            if (currentUser) {
                document.getElementById('login-btn').style.display = 'none';
                document.getElementById('user-profile').style.display = 'flex';
                
                // Use dbUsername, fallback to metadata, fallback to 'Player'
                const displayName = dbUsername || (currentUser.user_metadata ? currentUser.user_metadata.username : '') || 'Player';
                
                document.getElementById('profile-name').textContent = displayName;
                document.getElementById('username-input').value = displayName;
            } else {
                document.getElementById('login-btn').style.display = 'block';
                document.getElementById('user-profile').style.display = 'none';
            }
        }

        function updateForumUI() {
            const createUI = document.getElementById('forum-create-ui');
            const guestNotice = document.getElementById('forum-guest-notice');
            if (currentUser) {
                createUI.style.display = 'block';
                if (guestNotice) guestNotice.style.display = 'none';
            } else {
                createUI.style.display = 'none';
                if (guestNotice) guestNotice.style.display = 'block';
            }
        }

        async function handleLogin() {
            if (!sbClient) return;
            const email = document.getElementById('auth-email').value;
            const password = document.getElementById('auth-pass').value;
            
            const { data, error } = await sbClient.auth.signInWithPassword({ email, password });
            
            if (error) return showToast(error.message, 'error');
            
            currentUser = data.user;
            showToast('Logged In!', 'success');
            closeModal('login-modal');
            
            // Wait for profile fetch before continuing
            await fetchProfile();
            checkSession();
        }

       async function handleSignup() {
            if (!sbClient) return;
            const email = document.getElementById('signup-email').value.trim();
            const password = document.getElementById('signup-pass').value;
            const username = document.getElementById('signup-username').value.trim();
            
            if (!username) return showToast('Username required', 'error');
            if (username.length < 3) return showToast('Username too short (3+ chars)', 'error');
            if (username.length > 15) return showToast('Username too long (max 15 chars)', 'error');
            if (!/^[a-zA-Z0-9_]+$/.test(username)) return showToast('Username can only contain letters, numbers, and underscores', 'error');

            // 1. CHECK IF USERNAME EXISTS FIRST (case-insensitive)
            try {
                const { data: existingUser, error: checkError } = await sbClient
                    .from('profiles')
                    .select('username')
                    .ilike('username', username) // Case-insensitive match
                    .maybeSingle();

                if (existingUser) {
                    return showToast('Username already taken!', 'error');
                }
            } catch (checkError) {
                console.error('Username check failed:', checkError);
                // Continue anyway - the database unique constraint is the final guard
            }

            // 2. PROCEED WITH SIGNUP
            const { data, error } = await sbClient.auth.signUp({ 
                email, 
                password,
                options: {
                    data: { username: username }
                }
            });

            if (error) {
                // Handle specific signup errors
                if (error.message.includes('already registered')) {
                    return showToast('Email already registered!', 'error');
                }
                return showToast(error.message, 'error');
            }

            if (data.user) {
                // 3. CREATE PROFILE
                const { error: profileError } = await sbClient
                    .from('profiles')
                    .insert([{ id: data.user.id, username }]);

                if (profileError) {
                    console.error('Profile creation error:', profileError);
                    if (profileError.code === '23505') {
                        // Unique constraint violation - username was taken in a race condition
                        return showToast('Username already taken! Please try another.', 'error');
                    }
                    return showToast('Error creating profile. Please try again.', 'error');
                }

                // Success
                currentUser = data.user;
                dbUsername = username;
                updateAuthUI();
                updateForumUI();
                closeModal('signup-modal');
                showToast('Account Created!', 'success');
            }
        }

        async function signOut() {
            if (!sbClient) return;
            await sbClient.auth.signOut();
            currentUser = null; 
            dbUsername = ''; 
            isAdmin = false;
            
            updateAuthUI();
            updateForumUI();
            
            const adminToggle = document.getElementById('admin-toggle');
            if (adminToggle) adminToggle.style.display = 'none';
            
            const adminPanel = document.getElementById('admin-panel');
            if (adminPanel) adminPanel.classList.remove('visible');
            
            showToast('Logged out', 'info');
        }

        function openForum() { 
            openModal('forum-modal'); 
            updateForumUI();
            loadPosts();
        }

        async function loadPosts() {
            if (!sbClient) {
                document.getElementById('forum-posts').innerHTML = '<p style="text-align:center; opacity:0.6;">Forum unavailable ‚Äî please refresh.</p>';
                return;
            }
            const container = document.getElementById('forum-posts');
            container.innerHTML = '<p style="text-align:center; opacity:0.5; font-size:0.85rem;">Loading...</p>';
            try {
                const { data, error } = await sbClient.from('forum_posts').select('*').order('created_at', { ascending: false }).limit(30);
                const container = document.getElementById('forum-posts');
                container.innerHTML = '';
                if (error || !data || data.length === 0) {
                    container.innerHTML = '<p style="text-align:center; opacity:0.6;">No posts yet.</p>';
                    return;
                }
                
                for (const post of data) {
                    const commentsCount = await getCommentsCount(post.id);
                    const isOwnPost = currentUser && post.user_id === currentUser.id;
                    const div = document.createElement('div');
                    div.className = 'forum-post';
                    div.id = `post-${post.id}`;
                    div.innerHTML = `
                        <h4>${escapeHtml(post.title)}</h4>
                        <div class="meta">
                            <span>by <strong>${escapeHtml(post.author || 'Unknown')}</strong>${post.is_owner ? ' <span style="background:linear-gradient(135deg,#ffd700,#ff8c00);color:#000;font-size:0.65rem;font-weight:900;padding:2px 6px;border-radius:4px;letter-spacing:0.5px;">OWNER</span>' : ''}</span>
                            <span>‚Ä¢</span>
                            <span>${new Date(post.created_at).toLocaleDateString()}</span>
                            ${isOwnPost ? '<span style="color: rgba(255,255,255,0.5);">‚Ä¢ Your Post</span>' : ''}
                        </div>
                        <p class="post-content">${escapeHtml(post.description)}</p>
                        ${(isAdmin || isOwnPost) ? `<button class="delete-btn" onclick="deletePost('${post.id}')">Delete</button>` : ''}
                        <div class="comments-section">
                            <div class="comments-header">
                                <span>${commentsCount} comment${commentsCount !== 1 ? 's' : ''}</span>
                                <button class="toggle-comments" onclick="toggleComments('${post.id}')">Show Comments</button>
                            </div>
                            <div class="comments-list" id="comments-${post.id}"></div>
                            ${currentUser ? `
                                <div class="add-comment-form" id="comment-form-${post.id}">
                                    <input type="text" class="modern-input" id="comment-input-${post.id}" placeholder="Write a comment..." maxlength="200">
                                    <button class="btn-secondary" onclick="addComment('${post.id}')">Post</button>
                                </div>
                            ` : ''}
                        </div>
                    `;
                    container.appendChild(div);
                }
            } catch(e) {
                document.getElementById('forum-posts').innerHTML = '<p style="text-align:center; opacity:0.6;">Error loading.</p>';
            }
        }

        async function getCommentsCount(postId) {
            if (!sbClient) return 0;
            try {
                const { count } = await sbClient.from('forum_comments').select('*', { count: 'exact', head: true }).eq('post_id', postId);
                return count || 0;
            } catch(e) { return 0; }
        }

        async function toggleComments(postId) {
            const commentsList = document.getElementById(`comments-${postId}`);
            const commentForm = document.getElementById(`comment-form-${postId}`);
            const toggleBtn = commentsList.parentElement.querySelector('.toggle-comments');
            
            if (commentsList.classList.contains('visible')) {
                commentsList.classList.remove('visible');
                if (commentForm) commentForm.classList.remove('visible');
                toggleBtn.textContent = 'Show Comments';
            } else {
                await loadComments(postId);
                commentsList.classList.add('visible');
                if (commentForm) commentForm.classList.add('visible');
                toggleBtn.textContent = 'Hide Comments';
            }
        }

        async function loadComments(postId) {
            if (!sbClient) return;
            const commentsList = document.getElementById(`comments-${postId}`);
            commentsList.innerHTML = '<p style="text-align:center; opacity:0.6; font-size:0.8rem;">Loading...</p>';
            
            try {
                const { data, error } = await sbClient.from('forum_comments').select('*').eq('post_id', postId).order('created_at', { ascending: true });
                
                if (error || !data || data.length === 0) {
                    commentsList.innerHTML = '<p style="text-align:center; opacity:0.6; font-size:0.8rem;">No comments yet.</p>';
                    return;
                }
                
                // Organize comments by parent (for nested replies)
                const topLevelComments = data.filter(c => !c.parent_comment_id);
                const replies = data.filter(c => c.parent_comment_id);
                
                let html = '';
                for (const c of topLevelComments) {
                    html += renderComment(c, postId, false);
                    // Add replies to this comment
                    const commentReplies = replies.filter(r => r.parent_comment_id === c.id);
                    for (const reply of commentReplies) {
                        html += renderComment(reply, postId, true);
                    }
                    // Add reply form for this comment
                    if (currentUser) {
                        html += `
                            <div class="reply-form" id="reply-form-${c.id}">
                                <input type="text" class="modern-input" id="reply-input-${c.id}" placeholder="Reply to ${escapeHtml(c.author)}..." maxlength="200">
                                <button class="btn-secondary" onclick="addReply('${postId}', '${c.id}')">Reply</button>
                            </div>
                        `;
                    }
                }
                
                commentsList.innerHTML = html;
            } catch(e) {
                commentsList.innerHTML = '<p style="text-align:center; opacity:0.6; font-size:0.8rem;">Error loading comments.</p>';
            }
        }

        function renderComment(c, postId, isReply) {
            const canDelete = isAdmin;
            return `
                <div class="comment ${isReply ? 'reply' : ''}" id="comment-${c.id}">
                    <div class="comment-author">${escapeHtml(c.author || 'Unknown')}${c.is_owner ? ' <span style="background:linear-gradient(135deg,#ffd700,#ff8c00);color:#000;font-size:0.6rem;font-weight:900;padding:1px 5px;border-radius:3px;">OWNER</span>' : ''}</div>
                    <div class="comment-text">${escapeHtml(c.content)}</div>
                    <div class="comment-date">${new Date(c.created_at).toLocaleString()}</div>
                    <div class="comment-actions">
                        ${!isReply && currentUser ? `<button class="reply-btn" onclick="toggleReplyForm('${c.id}')">Reply</button>` : ''}
                        ${canDelete ? `<button class="delete-comment-btn" onclick="deleteComment('${c.id}', '${postId}')">Delete</button>` : ''}
                    </div>
                </div>
            `;
        }

        function toggleReplyForm(commentId) {
            const form = document.getElementById(`reply-form-${commentId}`);
            if (form) {
                const isVisible = form.classList.contains('visible');
                // Hide all other reply forms first
                document.querySelectorAll('.reply-form').forEach(f => f.classList.remove('visible'));
                if (!isVisible) {
                    form.classList.add('visible');
                    document.getElementById(`reply-input-${commentId}`).focus();
                }
            }
        }

        async function addReply(postId, parentCommentId) {
            if (!currentUser) return showToast('Please login to reply!', 'error');
            const input = document.getElementById(`reply-input-${parentCommentId}`);
            const content = input.value.trim();
            if (!content) return showToast('Reply cannot be empty!', 'error');
            
            try {
                const { error } = await sbClient.from('forum_comments').insert([{
                    post_id: postId,
                    parent_comment_id: parentCommentId,
                    content: content,
                    author: dbUsername || currentUser.email.split('@')[0] || 'Player',
                    user_id: currentUser.id,
                    is_owner: isAdmin
                }]);
                if (error) throw error;
                input.value = '';
                showToast('Reply posted!', 'success');
                await loadComments(postId);
                const header = document.querySelector(`#post-${postId} .comments-header span`);
                const count = await getCommentsCount(postId);
                header.textContent = `${count} comment${count !== 1 ? 's' : ''}`;
            } catch(e) { showToast('Error posting reply: ' + e.message, 'error'); }
        }

        async function addComment(postId) {
            if (!currentUser) return showToast('Please login to comment!', 'error');
            const input = document.getElementById(`comment-input-${postId}`);
            const content = input.value.trim();
            if (!content) return showToast('Comment cannot be empty!', 'error');
            
            try {
                const { error } = await sbClient.from('forum_comments').insert([{
                    post_id: postId,
                    content: content,
                    author: dbUsername || currentUser.email.split('@')[0] || 'Player',
                    user_id: currentUser.id,
                    is_owner: isAdmin
                }]);
                if (error) throw error;
                input.value = '';
                showToast('Comment posted!', 'success');
                await loadComments(postId);
                const header = document.querySelector(`#post-${postId} .comments-header span`);
                const count = await getCommentsCount(postId);
                header.textContent = `${count} comment${count !== 1 ? 's' : ''}`;
            } catch(e) { showToast('Error posting comment: ' + e.message, 'error'); }
        }

        async function deleteComment(commentId, postId) {
            if (!confirm('Delete this comment?')) return;
            try {
                const { error } = await sbClient.from('forum_comments').delete().eq('id', commentId);
                if (error) throw error;
                showToast('Comment deleted!', 'success');
                await loadComments(postId);
                const header = document.querySelector(`#post-${postId} .comments-header span`);
                const count = await getCommentsCount(postId);
                header.textContent = `${count} comment${count !== 1 ? 's' : ''}`;
            } catch(e) { showToast('Error deleting comment: ' + e.message, 'error'); }
        }

        async function createPost() {
            if (!currentUser) return showToast('Please login to post!', 'error');
            const title = document.getElementById('forum-title').value.trim();
            const desc = document.getElementById('forum-desc').value.trim();
            if (!title || !desc) return showToast('Fill all fields', 'error');
            
            try {
                const { error } = await sbClient.from('forum_posts').insert([{ 
                    title, 
                    description: desc, 
                    author: dbUsername || currentUser.email.split('@')[0] || 'Player', 
                    category: 'general',
                    user_id: currentUser.id,
                    is_owner: isAdmin
                }]);
                if (error) throw error;
                showToast('Posted!', 'success');
                document.getElementById('forum-title').value = '';
                document.getElementById('forum-desc').value = '';
                loadPosts();
            } catch(e) { showToast('Error: ' + e.message, 'error'); }
        }

        async function deletePost(postId) {
            if (!currentUser) { showToast('Please login!', 'error'); return; }
            if (!confirm('Delete this post and all its comments?')) return;
            try { 
                await sbClient.from('forum_comments').delete().eq('post_id', postId);
                const query = sbClient.from('forum_posts').delete().eq('id', postId);
                // Admin can delete any post; regular users can only delete their own
                if (!isAdmin) query.eq('user_id', currentUser.id);
                const { error } = await query;
                if (error) throw error;
                showToast('Deleted', 'success'); 
                loadPosts(); 
            } catch(e) { showToast('Error: ' + e.message, 'error'); }
        }

        function initAdminPanel() {
            // Regular powers grid
            const grid = document.getElementById('admin-powers-grid');
            if (grid) {
                grid.innerHTML = '';
                for (let key in POWERS) {
                    const p = POWERS[key];
                    grid.innerHTML += `<button class="power-grid-btn" onclick="adminGivePower('${key}')" style="border-color:${p.color};"><span style="color:${p.color};">${p.name.charAt(0)}</span><span>${p.name}</span></button>`;
                }
            }
            
            // Admin-only omega powers grid
            const omegaGrid = document.getElementById('admin-omega-grid');
            if (omegaGrid) {
                omegaGrid.innerHTML = '';
                for (let key in ADMIN_POWERS) {
                    const p = ADMIN_POWERS[key];
                    omegaGrid.innerHTML += `<button class="power-grid-btn" onclick="adminGivePower('${key}')" style="border-color:${p.color}; background: rgba(255,215,0,0.1);"><span style="color:${p.color};">${p.name.charAt(0)}</span><span>${p.name}</span></button>`;
                }
            }
            
            // Spawn power select (regular + admin powers)
            const select = document.getElementById('spawn-power-select');
            if (select) {
                select.innerHTML = '<option value="">Select...</option>';
                for (let key in POWERS) select.innerHTML += `<option value="${key}">${POWERS[key].name}</option>`;
                select.innerHTML += '<option disabled>‚îÄ‚îÄ Admin Powers ‚îÄ‚îÄ</option>';
                for (let key in ADMIN_POWERS) select.innerHTML += `<option value="${key}">${ADMIN_POWERS[key].name}</option>`;
            }
        }

        function toggleAdminPanel() { if (isAdmin) document.getElementById('admin-panel').classList.toggle('visible'); }

        function adminGivePower(powerKey) {
            if (!isAdmin || !state.me) return;
            state.inventory[state.activeSlot] = powerKey;
            state.me.currentPower = powerKey;
            state.me.isOmegaPower = !!(OMEGA_POWER[powerKey]);
            state.me.isAdminPower = !!(ADMIN_POWERS[powerKey]);
            updateInventoryUI();
            broadcastState();
            showToast(`Got ${ALL_POWERS[powerKey].name}!`, 'admin');
        }

        function adminAction(action) {
            if (!isAdmin || !state.me) return;
            switch(action) {
                case 'heal':
                    state.me.hp = 100;
                    spawnParticles(state.me.x, state.me.y, 30, '#22c55e');
                    showToast('Full heal!', 'admin');
                    break;
                case 'kill_all':
                    for (let id in state.players) forceKillPlayer(id);
                    showToast('Killed all!', 'admin');
                    break;
                case 'teleport_center':
                    state.me.x = CONFIG.map.width / 2;
                    state.me.y = CONFIG.map.height / 2;
                    emitAbilityEffect('teleport', state.me.x, state.me.y);
                    showToast('Teleported!', 'admin');
                    break;
                case 'add_kills':
                    state.kills += 10;
                    state.killsThisLife += 10;
                    state.me.kills = state.kills;
                    updateKillCounter();
                    if (state.killsThisLife >= 5 && state.inventorySlots < 3) {
                        state.inventorySlots = 3;
                        updateInventoryUI();
                    }
                    if (state.kills >= state.nextOmegaThreshold && !state.omegaUnlocked) unlockOmega();
                    showToast('+10 kills!', 'admin');
                    break;
                case 'toggle_godmode':
                    state.adminGodMode = !state.adminGodMode;
                    document.getElementById('godmode-btn').textContent = `God Mode: ${state.adminGodMode ? 'ON' : 'OFF'}`;
                    document.getElementById('godmode-btn').classList.toggle('active', state.adminGodMode);
                    showToast(`God Mode: ${state.adminGodMode ? 'ON' : 'OFF'}`, 'admin');
                    break;
                case 'toggle_infinite':
                    state.adminInfinite = !state.adminInfinite;
                    document.getElementById('infinite-btn').textContent = `Infinite Power: ${state.adminInfinite ? 'ON' : 'OFF'}`;
                    document.getElementById('infinite-btn').classList.toggle('active', state.adminInfinite);
                    showToast(`Infinite: ${state.adminInfinite ? 'ON' : 'OFF'}`, 'admin');
                    break;
                case 'spawn_power':
                    const sel = document.getElementById('spawn-power-select').value;
                    if (sel && ALL_POWERS[sel]) {
                        const dropId = 'admin_' + Date.now();
                        state.powerups[dropId] = { id: dropId, type: sel, x: state.mouse.worldX, y: state.mouse.worldY };
                        spawnParticles(state.mouse.worldX, state.mouse.worldY, 20, ALL_POWERS[sel].color);
                        showToast(`Spawned ${ALL_POWERS[sel].name}!`, 'admin');
                    }
                    break;
                case 'heal_all':
                    for (let id in state.players) {
                        socket.emit('playerHit', { targetId: id, damage: -100, attackerId: myId });
                        spawnParticles(state.players[id].x, state.players[id].y, 15, '#22c55e');
                    }
                    showToast('Healed everyone!', 'admin');
                    break;
                case 'clear_powerups':
                    state.powerups = {};
                    showToast('Cleared all powerups!', 'admin');
                    break;
                case 'respawn_all':
                    for (let id in state.players) {
                        socket.emit('playerDied', { victimId: id, killerId: myId });
                    }
                    showToast('Respawned all!', 'admin');
                    break;
            }
        }

        function adminSpawnBoss() {
            if (!isAdmin || !socket) return;
            socket.emit('adminAnnouncement', { message: '‚ö†Ô∏è Admin is spawning the BOSS!' });
            // Tell server to spawn boss immediately via a special emit
            socket.emit('adminSpawnBoss');
            showToast('Boss spawning!', 'admin');
        }

        function sendAnnouncement() {
            if (!isAdmin || !socket) return;
            const text = document.getElementById('announce-text').value.trim();
            if (!text) return showToast('Type something to announce!', 'warning');
            socket.emit('adminAnnouncement', { message: text });
            document.getElementById('announce-text').value = '';
            showToast('Announcement sent!', 'admin');
        }

        function showAnnouncement(msg) {
            const el = document.getElementById('game-announcement');
            const msgEl = document.getElementById('announce-message');
            msgEl.textContent = msg;
            el.classList.remove('visible');
            // Force reflow to restart animation
            void el.offsetWidth;
            el.classList.add('visible');
            setTimeout(() => el.classList.remove('visible'), 5000);
        }

        function emitAbilityEffect(type, x, y, extra = {}) {
            if (!socket) return;
            socket.emit('abilityUsed', { type, x, y, id: myId, ...extra });
        }

        function broadcastState() {
            if (!socket || !state.me) return;
            socket.emit('move', {
                x: state.me.x, y: state.me.y, angle: state.me.angle, kills: state.kills,
                currentPower: state.me.currentPower, hp: state.me.hp, speedActive: state.speedActive,
                berserkerActive: state.berserkerActive, phaseActive: state.phaseActive,
                mirrorActive: state.mirrorActive, isOwner: isAdmin
            });
        }

        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize);
        resize();

       function joinGame() {
    if (isConnecting) return;
    if (typeof io === 'undefined') return showToast('Server Error', 'error');

    const playBtn = document.getElementById('play-btn');
    const connectStatus = document.getElementById('connecting-status');
    isConnecting = true;
    playBtn.disabled = true;
    connectStatus.style.display = 'block';
    connectionAttempts++;
    connectStatus.textContent = `Connecting... (${connectionAttempts})`;

    const name = document.getElementById('username-input').value.trim() || dbUsername || 'Guest';
    if (socket) { socket.disconnect(); socket = null; }

    let connectionTimeout = setTimeout(() => {
        if (isConnecting) {
            isConnecting = false;
            playBtn.disabled = false;
            connectStatus.style.display = 'none';
            showToast('Connection timeout! Server may be waking up...', 'warning');
            if (socket) socket.disconnect();
            socket = null;
        }
    }, 20000);

    socket = io(CONFIG.serverUrl, { 
        timeout: 15000, 
        reconnectionAttempts: 5,
        transports: ['websocket', 'polling']
    });

    socket.on('connect', () => {
        myId = socket.id;
        const userId = currentUser ? currentUser.id : null;
        socket.emit('join', { name, userId });
    });

    socket.on('duplicateSession', (data) => {
        clearTimeout(connectionTimeout);
        isConnecting = false;
        playBtn.disabled = false;
        connectStatus.style.display = 'none';
        showToast(data.message || 'This account is already playing!', 'error');
        socket.disconnect();
        socket = null;
    });

    socket.on('joinSuccess', () => {
        clearTimeout(connectionTimeout);
        document.getElementById('main-menu').style.display = 'none';
        document.getElementById('top-left-ui').style.display = 'none';
        document.getElementById('top-right-ui').style.display = 'none';
        document.getElementById('hud-bottom').style.display = 'flex';
        document.getElementById('leaderboard').style.display = 'block';
        document.getElementById('chat-wrap').style.display = 'block';
        document.getElementById('kill-counter').style.display = 'block';
        const updatePanel = document.getElementById('update-panel');
        if (updatePanel) updatePanel.style.display = 'none';
        if (isAdmin) document.getElementById('admin-toggle').style.display = 'block';
        // Show emote button
        document.getElementById('emote-toggle-btn').classList.add('ingame');
        document.getElementById('emote-hint').classList.add('ingame');
        updateEmoteWheelBtns();
        isConnecting = false;
        connectionAttempts = 0;
        // Announce owner joining to everyone
        if (isAdmin && socket) {
            socket.emit('adminAnnouncement', { message: 'üëë The Owner Astraphobia Has Joined!' });
        }
    });

    socket.on('connect_error', (error) => {
        connectStatus.textContent = `Connecting... (${connectionAttempts}) - Retrying...`;
        if (connectionAttempts >= 5) {
            clearTimeout(connectionTimeout);
            isConnecting = false;
            playBtn.disabled = false;
            connectStatus.style.display = 'none';
            showToast('Cannot reach server! Try again later.', 'error');
            connectionAttempts = 0;
        }
    });

    socket.on('disconnect', () => { 
        clearTimeout(connectionTimeout);
        if (state.running) { 
            showToast('Disconnected!', 'error'); 
            state.running = false; 
        } 
    });

    setupSocketHandlers();
}

        function resetGameState() {
            state.me = null; state.players = {}; state.projectiles = {}; state.powerups = {};
            state.particles = []; state.clones = []; state.explosions = []; state.meteors = []; state.timebombs = [];
            state.remoteClones = {}; state.speedActive = false; state.phaseActive = false;
            state.berserkerActive = false; state.shootCooldown = 0; state.cloneTimer = 0;
            state.kills = 0; state.omegaUnlocked = false; state.omegaPower = null;
            state.omegaTimer = 0; state.mirrorActive = false;
            state.timestopActive = false; state.hitCooldowns = {}; state.isDead = false;
            state.nextOmegaThreshold = 10; state.baby = null; state.babyShootCooldown = 0; state.remoteBabies = {};
            state.bosses = {};
            state.npcs = {};
            state.activeEmoteBubbles = {};
            state.inventory = [null, null, null]; state.activeSlot = 0;
            state.inventorySlots = 1; state.killsThisLife = 0; state.slotCooldowns = [0, 0, 0];
            state.sprinting = false; state.stamina = 100; state.staminaDepleted = false; state.staminaDepletedTimer = 0;
            updateKillCounter();
        }

        function setupSocketHandlers() {
            socket.on('init', (data) => {
                // Reset game state at the START of init
                state.particles = []; state.clones = []; state.explosions = []; state.meteors = []; state.timebombs = [];
                state.remoteClones = {}; state.speedActive = false; state.phaseActive = false;
                state.berserkerActive = false; state.shootCooldown = 0; state.cloneTimer = 0;
                state.kills = 0; state.omegaUnlocked = false; state.omegaPower = null;
                state.omegaTimer = 0; state.adminGodMode = false; state.adminInfinite = false;
                state.mirrorActive = false; state.timestopActive = false; state.hitCooldowns = {}; state.isDead = false;
                state.nextOmegaThreshold = 10; state.baby = null; state.babyShootCooldown = 0; state.remoteBabies = {};
                state.inventory = [null, null, null]; state.activeSlot = 0;
                state.inventorySlots = 1; state.killsThisLife = 0; state.slotCooldowns = [0, 0, 0];
                state.sprinting = false; state.stamina = 100; state.staminaDepleted = false; state.staminaDepletedTimer = 0;
                
                state.me = data.player;
                state.me.recoil = 0; state.me.poisoned = 0; state.me.frozen = 0;
                state.me.kills = 0; state.me.isOmegaPower = false;
                state.spawnProtection = 3.0; // 3s invincibility on join
                state.players = {};
                Object.keys(data.players || {}).forEach(id => {
                    if (id !== myId) {
                        state.players[id] = { ...data.players[id], targetX: data.players[id].x, targetY: data.players[id].y, kills: 0 };
                    }
                });
                state.projectiles = data.projectiles || {};
                state.powerups = data.powerups || {};
                // Load existing bosses from server state
                if (data.bosses) {
                    for (const id in data.bosses) {
                        state.bosses[id] = { ...data.bosses[id], targetX: data.bosses[id].x, targetY: data.bosses[id].y };
                    }
                }
                // Load existing NPCs
                state.npcs = {};
                if (data.npcs) {
                    for (const id in data.npcs) {
                        state.npcs[id] = { ...data.npcs[id], targetX: data.npcs[id].x, targetY: data.npcs[id].y };
                    }
                }
                
                updateKillCounter();
                
                // Start game loop here after player data is loaded
                if (!state.running) {
                    state.running = true;
                    state.lastTime = performance.now();
                    requestAnimationFrame(loop);
                }
            });

            socket.on('playerJoined', p => { if (p.id !== myId) { state.players[p.id] = { ...p, targetX: p.x, targetY: p.y, kills: 0 }; } });
            socket.on('playerLeft', id => { delete state.players[id]; delete state.remoteClones[id]; if (state.remoteBabies) delete state.remoteBabies[id]; });

            socket.on('playerMoved', (data) => {
                if (data.id !== myId && state.players[data.id]) {
                    const p = state.players[data.id];
                    p.targetX = data.x; p.targetY = data.y; p.angle = data.angle;
                    if (data.currentPower !== undefined) p.currentPower = data.currentPower;
                    if (data.kills !== undefined) p.kills = data.kills;
                    if (data.hp !== undefined) p.hp = data.hp;
                    if (data.speedActive !== undefined) p.speedActive = data.speedActive;
                    if (data.berserkerActive !== undefined) p.berserkerActive = data.berserkerActive;
                    if (data.phaseActive !== undefined) p.phaseActive = data.phaseActive;
                    if (data.mirrorActive !== undefined) p.mirrorActive = data.mirrorActive;
                    if (data.isOwner !== undefined) p.isOwner = data.isOwner;
                }
            });

            socket.on('powerupSpawn', p => { if (p && p.id && p.type && ALL_POWERS[p.type]) state.powerups[p.id] = p; });
            socket.on('powerupTaken', id => delete state.powerups[id]);
            
            // Auto-spawn extra powerups client-side to keep map full
            function autoSpawnPowerups() {
                const currentCount = Object.keys(state.powerups).length;
                const target = 35; // Keep at least 35 powerups on map
                if (currentCount < target && state.running) {
                    const spawnCount = Math.min(5, target - currentCount);
                    const powerKeys = Object.keys(POWERS);
                    // Weight toward mythic/legendary
                    const weightedKeys = powerKeys.filter(k => k !== 'baby');
                    for (let i = 0; i < spawnCount; i++) {
                        const key = weightedKeys[Math.floor(Math.random() * weightedKeys.length)];
                        const id = 'auto_' + (powerupIdCounter++);
                        state.powerups[id] = {
                            id, type: key,
                            x: 100 + Math.random() * (CONFIG.map.width - 200),
                            y: 100 + Math.random() * (CONFIG.map.height - 200)
                        };
                    }
                }
                if (state.running) setTimeout(autoSpawnPowerups, 3000);
            }
            setTimeout(autoSpawnPowerups, 5000);
            // Initial bulk spawn on game start
            setTimeout(() => {
                if (!state.running) return;
                const allPowerKeys = Object.keys(POWERS).filter(k => k !== 'baby');
                for (let i = 0; i < 40; i++) {
                    const key = allPowerKeys[Math.floor(Math.random() * allPowerKeys.length)];
                    const id = 'init_' + (powerupIdCounter++);
                    state.powerups[id] = {
                        id, type: key,
                        x: 100 + Math.random() * (CONFIG.map.width - 200),
                        y: 100 + Math.random() * (CONFIG.map.height - 200)
                    };
                }
                // Spawn 1 of each mythic powerup on map start
                ['baby', 'phoenix', 'soulsteal'].forEach((k, i) => {
                    const id = 'mythic_' + i;
                    state.powerups[id] = {
                        id, type: k,
                        x: 200 + Math.random() * (CONFIG.map.width - 400),
                        y: 200 + Math.random() * (CONFIG.map.height - 400)
                    };
                });
            }, 3000);

            // Force position update (from swap)
            socket.on('forceMovePlayer', (data) => {
                if (state.me && !state.isDead) {
                    spawnParticles(state.me.x, state.me.y, 20, '#ec4899');
                    state.me.x = data.x;
                    state.me.y = data.y;
                    spawnParticles(state.me.x, state.me.y, 20, '#ec4899');
                    broadcastState();
                    showToast('You got swapped!', 'warning');
                }
            });

            // Admin announcement
            socket.on('announcement', (data) => {
                showAnnouncement(data.message);
            });

            socket.on('chatMessage', data => {
                const history = document.getElementById('chat-history');
                const div = document.createElement('div');
                div.className = 'chat-msg';
                div.innerHTML = `<b>${escapeHtml(data.playerName)}:</b> ${escapeHtml(data.text)}`;
                history.appendChild(div);
                history.scrollTop = history.scrollHeight;
            });

            // ‚îÄ‚îÄ BOSS EVENTS ‚îÄ‚îÄ
            socket.on('bossSpawn', (data) => {
                state.bosses[data.id] = { ...data, targetX: data.x, targetY: data.y };
                spawnParticles(data.x, data.y, 80, '#ff0000');
            });

            socket.on('bossMoved', (data) => {
                if (!state.bosses[data.bossId]) state.bosses[data.bossId] = { id: data.bossId, maxHp: 1000 };
                const b = state.bosses[data.bossId];
                b.targetX = data.x;
                b.targetY = data.y;
                b.angle = data.angle;
                b.hp = data.hp;
            });

            socket.on('bossDied', (data) => {
                const b = state.bosses[data.bossId];
                if (b) {
                    state.explosions.push({ x: b.x || data.bossX, y: b.y || data.bossY, radius: 80, maxRadius: 600, life: 2, color: '#ff0000' });
                    for (let i = 0; i < 100; i++) spawnParticles(data.bossX, data.bossY, 1, ['#ff0000','#ffd700','#ff6b00'][Math.floor(Math.random()*3)]);
                }
                delete state.bosses[data.bossId];
                if (data.drops) {
                    data.drops.forEach(d => { if (ALL_POWERS[d.type]) state.powerups[d.id] = d; });
                }
            });

            // NPC SOCKET EVENTS
            socket.on('npcSpawn', (data) => {
                state.npcs[data.id] = { ...data, targetX: data.x, targetY: data.y };
            });
            socket.on('npcMoved', (data) => {
                if (!state.npcs[data.npcId]) state.npcs[data.npcId] = { id: data.npcId };
                const n = state.npcs[data.npcId];
                n.targetX = data.x; n.targetY = data.y;
                n.angle = data.angle; n.hp = data.hp;
            });
            socket.on('npcDied', (data) => {
                const n = state.npcs[data.npcId];
                if (n) {
                    const color = NPC_COLORS[data.rarity] || '#fff';
                    for (let i = 0; i < 30; i++) spawnParticles(n.x||data.x, n.y||data.y, 1, color);
                    state.explosions.push({ x: n.x||data.x, y: n.y||data.y, radius: 15, maxRadius: 80, life: 0.5, color });
                }
                delete state.npcs[data.npcId];
                if (data.drops) data.drops.forEach(d => { if (ALL_POWERS[d.type]) state.powerups[d.id] = d; });
            });
            // EMOTE SOCKET EVENTS
            socket.on('playerEmote', (data) => {
                state.activeEmoteBubbles[data.playerId] = { emote: data.emote, timer: 3.0 };
            });

            socket.on('playerDied', data => {
                if (data.victimId === myId && !state.isDead) {
                    state.me.hp = 0;
                    handleDeath(data.killerId);
                }
                if (state.players[data.victimId]) {
                    state.players[data.victimId].hp = 0;
                    spawnParticles(state.players[data.victimId].x, state.players[data.victimId].y, 30, '#ef4444');
                    state.players[data.victimId].kills = 0;
                    delete state.remoteClones[data.victimId];
                    if (state.remoteBabies) delete state.remoteBabies[data.victimId];
                }
                if (data.killerId === myId && data.victimId !== myId) {
                    state.kills++;
                    state.killsThisLife++;
                    state.me.kills = state.kills;
                    updateKillCounter();
                    showToast(`Kill! (${state.kills}/${state.nextOmegaThreshold})`, 'kill');
                    // Unlock 3 inventory slots at 5 kills this life
                    if (state.killsThisLife === 5 && state.inventorySlots < 3) {
                        state.inventorySlots = 3;
                        updateInventoryUI();
                        showToast('+ 3 Inventory Slots Unlocked!', 'success');
                    }
                    if (state.kills >= state.nextOmegaThreshold && !state.omegaUnlocked) unlockOmega();
                }
            });

            socket.on('playerHit', data => {
                if (data.targetId === myId && state.me && !state.isDead) {
                    if (state.adminGodMode) return;
                    if (state.spawnProtection > 0) return; // invincible after spawn
                    if (state.mirrorActive && data.attackerId) {
                        socket.emit('playerHit', { targetId: data.attackerId, damage: data.damage, attackerId: myId });
                        spawnParticles(state.me.x, state.me.y, 10, '#c0c0c0');
                        return;
                    }
                    let damage = data.damage || 20;
                    if (state.me.currentPower === 'shield') damage = Math.floor(damage * 0.5);
                    if (state.me.currentPower === 'tank') damage = Math.floor(damage * 0.25);
                    if (state.me.currentPower === 'berserker' && state.berserkerActive) damage *= 2;
                    state.me.hp -= damage;
                    spawnDamageNumber(state.me.x, state.me.y, damage, 'damage');
                    spawnParticles(state.me.x, state.me.y, 10, '#ef4444');
                    if (state.me.hp <= 0 && !state.isDead) {
                        if (state.me.currentPower === 'phoenix') {
                            // Phoenix revive!
                            state.me.hp = 80;
                            state.inventory[state.activeSlot] = null;
                            state.me.currentPower = null;
                            updateInventoryUI();
                            spawnParticles(state.me.x, state.me.y, 60, '#ff6600');
                            state.explosions.push({ x: state.me.x, y: state.me.y, radius: 20, maxRadius: 200, life: 1, color: '#ff6600' });
                            showToast('PHOENIX REVIVED! +80 HP', 'mythic');
                            broadcastState();
                        } else {
                            state.isDead = true;
                            socket.emit('playerDied', { victimId: myId, killerId: data.attackerId });
                        }
                    }
                }
            });

            socket.on('remoteShoot', data => {
                if (data.ownerId === myId) return;
                const id = 'remote_' + Math.random();
                state.projectiles[id] = {
                    id, x: data.x, y: data.y, angle: data.angle, type: data.type,
                    speed: data.speed || 600, color: data.color || '#ef4444', life: 3,
                    owner: data.ownerId, damage: data.damage || 20, localUpdate: true, isRemote: true
                };
            });

            socket.on('abilityEffect', data => {
                const { type, x, y, id } = data;
                if (id === myId) return;
                switch(type) {
                    // ‚îÄ‚îÄ EXISTING EFFECTS ‚îÄ‚îÄ
                    case 'laserbeam':
                        state.laserBeams.push({ x1: x, y1: y, x2: data.x2, y2: data.y2, life: 1 });
                        break;
                    case 'rockettrail':
                        state.rocketTrails.push({ x, y, life: 1 });
                        spawnParticles(x, y, 5, '#fb923c');
                        break;
                    case 'nuke':
                        state.explosions.push({ x, y, radius: 50, maxRadius: 400, life: 1, color: '#dc2626' });
                        for (let i = 0; i < 60; i++) spawnParticles(x, y, 1, ['#dc2626', '#f59e0b', '#fbbf24'][Math.floor(Math.random() * 3)]);
                        break;
                    case 'dash': spawnParticles(x, y, 15, '#f59e0b'); break;
                    case 'teleport': spawnParticles(x, y, 20, '#10b981'); break;
                    case 'heal': spawnParticles(x, y, 20, '#22c55e'); break;
                    case 'blackhole':
                        state.explosions.push({ x, y, radius: 10, maxRadius: 200, life: 1.5, color: '#1e1b4b' });
                        spawnParticles(x, y, 40, '#4c1d95');
                        break;
                    case 'shockwave':
                        state.explosions.push({ x, y, radius: 30, maxRadius: 200, life: 0.5, color: '#8b5cf6' });
                        break;
                    case 'emp':
                        state.explosions.push({ x, y, radius: 30, maxRadius: 250, life: 0.8, color: '#6366f1' });
                        spawnParticles(x, y, 30, '#6366f1');
                        break;
                    case 'swap': spawnParticles(x, y, 20, '#ec4899'); break;
                    case 'clone':
                        spawnParticles(x, y, 40, '#14b8a6');
                        if (!state.remoteClones[id]) state.remoteClones[id] = [];
                        for (let i = 0; i < 3; i++) {
                            state.remoteClones[id].push({
                                ownerId: id, offsetAngle: (i * (Math.PI * 2) / 3), timer: 12,
                                x: x, y: y, angle: 0, name: state.players[id] ? state.players[id].name : 'Clone',
                                hp: 50, kills: 0, currentPower: 'clone'
                            });
                        }
                        break;
                    case 'annihilator':
                        state.explosions.push({ x, y, radius: 50, maxRadius: 500, life: 1, color: '#ff0000' });
                        for (let i = 0; i < 50; i++) spawnParticles(x, y, 1, '#ff0000');
                        break;
                    case 'meteor':
                        for (let i = 0; i < 10; i++) {
                            state.meteors.push({
                                x: x + (Math.random() - 0.5) * 400,
                                y: y - 200 - Math.random() * 200,
                                targetY: y + Math.random() * 300,
                                speed: 400 + Math.random() * 200
                            });
                        }
                        break;
                    case 'vortex':
                        state.explosions.push({ x, y, radius: 50, maxRadius: 600, life: 2, color: '#7c3aed' });
                        break;
                    case 'supernova':
                        state.explosions.push({ x, y, radius: 100, maxRadius: 1000, life: 1.5, color: '#fff700' });
                        for (let i = 0; i < 100; i++) spawnParticles(x, y, 1, ['#fff700', '#ffd700', '#ff6b00'][Math.floor(Math.random() * 3)]);
                        break;

                    // ‚îÄ‚îÄ NEWLY SYNCED EFFECTS ‚îÄ‚îÄ
                    case 'lightning':
                        // 3 delayed bolts in the target area - use pre-generated positions if available
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                const bx = (data.pts && data.pts[i]) ? data.pts[i].x : x + (Math.random()-0.5)*80;
                                const by = (data.pts && data.pts[i]) ? data.pts[i].y : y + (Math.random()-0.5)*80;
                                state.explosions.push({ x: bx, y: by, radius: 5, maxRadius: 80, life: 0.5, color: '#facc15' });
                                spawnParticles(bx, by, 20, '#facc15');
                            }, i * 120);
                        }
                        break;
                    case 'poison':
                        state.explosions.push({ x, y, radius: 10, maxRadius: 180, life: 1.5, color: '#84cc16' });
                        spawnParticles(x, y, 40, '#84cc16');
                        break;
                    case 'poisontick':
                        // Ongoing poison cloud particles
                        for (let i = 0; i < 5; i++) {
                            spawnParticles(x + (Math.random()-0.5)*180, y + (Math.random()-0.5)*180, 1, '#84cc16');
                        }
                        break;
                    case 'frostnova':
                        state.explosions.push({ x, y, radius: 40, maxRadius: 300, life: 1, color: '#a5f3fc' });
                        for (let i = 0; i < 50; i++) {
                            const ang = (i / 50) * Math.PI * 2;
                            const d = 50 + Math.random() * 250;
                            spawnParticles(x + Math.cos(ang)*d, y + Math.sin(ang)*d, 3, '#a5f3fc');
                        }
                        break;
                    case 'gravitypull':
                        state.explosions.push({ x, y, radius: 50, maxRadius: 400, life: 1, color: '#7c3aed' });
                        for (let i = 0; i < 40; i++) {
                            const ang = (i / 40) * Math.PI * 2;
                            spawnParticles(x + Math.cos(ang)*400, y + Math.sin(ang)*400, 2, '#7c3aed');
                        }
                        break;
                    case 'soulrip':
                        state.explosions.push({ x, y, radius: 20, maxRadius: 380, life: 1.2, color: '#7c00ff' });
                        spawnParticles(x, y, 60, '#a855f7');
                        for (let i = 0; i < 20; i++) {
                            const ang = (i / 20) * Math.PI * 2;
                            spawnParticles(x + Math.cos(ang) * 380, y + Math.sin(ang) * 380, 3, '#7c00ff');
                        }
                        break;
                    case 'timebomb':
                        // Add to timebombs list - same small pulsing indicator as caster sees
                        spawnParticles(x, y, 20, '#ff6b00');
                        state.timebombs.push({ id: data.bombId || ('rbomb_' + Date.now()), x, y, timer: 2.0 });
                        break;
                    case 'timebombexplode':
                        state.explosions.push({ x, y, radius: 30, maxRadius: 250, life: 0.8, color: '#ff6b00' });
                        for (let i = 0; i < 40; i++) spawnParticles(x, y, 1, '#ff6b00');
                        // Remove matching timebomb indicator
                        if (data.bombId) {
                            const rbi = state.timebombs.findIndex(b => b.id === data.bombId);
                            if (rbi !== -1) state.timebombs.splice(rbi, 1);
                        }
                        break;
                    case 'orbitallaser':
                        // Warning flash before strike
                        for (let i = 0; i < 30; i++) spawnParticles(x + (Math.random()-0.5)*100, -50, 1, '#00f5ff');
                        state.explosions.push({ x, y, radius: 10, maxRadius: 50, life: 1.5, color: '#00f5ff' });
                        break;
                    case 'orbitallaserfire':
                        for (let i = 0; i < 100; i++) spawnParticles(x, i * 50, 2, '#00f5ff');
                        state.explosions.push({ x, y, radius: 40, maxRadius: 200, life: 1, color: '#00f5ff' });
                        break;
                    case 'shadowclone':
                        spawnParticles(x, y, 30, '#1a1a2e');
                        state.explosions.push({ x, y, radius: 10, maxRadius: 40, life: 1, color: '#1a1a2e' });
                        break;
                    case 'shadowcloneexplode':
                        state.explosions.push({ x, y, radius: 30, maxRadius: 180, life: 0.6, color: '#1a1a2e' });
                        spawnParticles(x, y, 20, '#1a1a2e');
                        break;
                    case 'chaos':
                        state.explosions.push({ x, y, radius: 30, maxRadius: 250, life: 1, color: '#ec4899' });
                        spawnParticles(x, y, 50, '#ec4899');
                        break;
                    case 'mirror':
                        for (let i = 0; i < 20; i++) {
                            const ang = (i / 20) * Math.PI * 2;
                            spawnParticles(x + Math.cos(ang)*50, y + Math.sin(ang)*50, 2, '#c0c0c0');
                        }
                        state.explosions.push({ x, y, radius: 10, maxRadius: 60, life: 0.5, color: '#c0c0c0' });
                        break;
                    // Baby tracking
                    case 'babyspawn':
                        if (!state.remoteBabies) state.remoteBabies = {};
                        state.remoteBabies[id] = { x, y, angle: 0, hp: 50 };
                        spawnParticles(x, y, 30, '#ff69b4');
                        break;
                    case 'babypos':
                        if (!state.remoteBabies) state.remoteBabies = {};
                        if (!state.remoteBabies[id]) state.remoteBabies[id] = { x, y, angle: data.angle || 0, hp: data.hp || 50 };
                        state.remoteBabies[id].x = x; state.remoteBabies[id].y = y;
                        state.remoteBabies[id].angle = data.angle || 0; state.remoteBabies[id].hp = data.hp || 50;
                        break;
                    case 'babyrecall':
                    case 'babydied':
                    case 'babydestruct':
                        if (state.remoteBabies) delete state.remoteBabies[id];
                        spawnParticles(x, y, 20, '#ff69b4');
                        if (type === 'babydestruct') {
                            state.explosions.push({ x, y, radius: 20, maxRadius: 200, life: 0.8, color: '#ff69b4' });
                        }
                        break;
                    // ‚îÄ‚îÄ ADMIN POWER EFFECTS ‚îÄ‚îÄ
                    case 'apocalypse':
                        if (data.pts) data.pts.forEach((pt, i) => {
                            setTimeout(() => {
                                state.explosions.push({ x: pt.x, y: pt.y, radius: 40, maxRadius: 300, life: 1, color: '#ff0000' });
                                spawnParticles(pt.x, pt.y, 15, '#ff0000');
                            }, i * 200);
                        });
                        break;
                    case 'chronobreak':
                        if (data.pts) data.pts.forEach(pt => spawnParticles(pt.x, pt.y, 1, '#00ffff'));
                        else for (let i = 0; i < 100; i++) spawnParticles(x + (Math.random()-0.5)*500, y + (Math.random()-0.5)*500, 1, '#00ffff');
                        state.explosions.push({ x, y, radius: 50, maxRadius: 400, life: 2, color: '#00ffff' });
                        break;
                    case 'voidrift':
                        state.explosions.push({ x, y, radius: 100, maxRadius: 800, life: 2, color: '#9333ea' });
                        spawnParticles(x, y, 60, '#9333ea');
                        break;
                    case 'armageddon':
                        if (data.pts) data.pts.forEach(pt => {
                            setTimeout(() => {
                                state.meteors.push({ x: pt.x, y: -400, targetY: pt.y, speed: 1200 });
                            }, pt.delay || 0);
                        });
                        break;
                    case 'omegabeam':
                        if (data.angle !== undefined) {
                            for (let i = 0; i < 100; i++) {
                                spawnParticles(x + Math.cos(data.angle)*i*50, y + Math.sin(data.angle)*i*50, 3, '#06b6d4');
                            }
                        }
                        state.explosions.push({ x, y, radius: 50, maxRadius: 5000, life: 1.5, color: '#06b6d4' });
                        break;
                    case 'singularity':
                        state.explosions.push({ x, y, radius: 10, maxRadius: 600, life: 5, color: '#000000' });
                        for (let i = 0; i < 5; i++) setTimeout(() => spawnParticles(x, y, 30, '#000000'), i * 500);
                        break;
                    case 'realitybomb':
                        for (let i = 0; i < 20; i++) {
                            setTimeout(() => {
                                const d = (i / 20) * 500;
                                for (let ang = 0; ang < Math.PI * 2; ang += 0.5) {
                                    spawnParticles(x + Math.cos(ang)*d, y + Math.sin(ang)*d, 2, '#ec4899');
                                }
                            }, i * 50);
                        }
                        break;
                    case 'godmode':
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                state.explosions.push({ x, y, radius: 50, maxRadius: 400, life: 0.5, color: '#ffd700' });
                            }, i * 300);
                        }
                        spawnParticles(x, y, 50, '#ffd700');
                        break;
                    case 'obliterate':
                        if (data.pts) data.pts.forEach(pt => {
                            state.explosions.push({ x: pt.x, y: pt.y, radius: 100, maxRadius: 600, life: 1, color: '#dc2626' });
                            spawnParticles(pt.x, pt.y, 20, '#dc2626');
                        });
                        break;
                    case 'dimensionrift':
                        state.explosions.push({ x, y, radius: 100, maxRadius: 1000, life: 2, color: '#8b00ff' });
                        spawnParticles(x, y, 80, '#8b00ff');
                        break;
                    case 'cosmicstorm':
                        for (let wave = 0; wave < 8; wave++) {
                            setTimeout(() => {
                                const ang = (wave / 8) * Math.PI * 2;
                                for (let d = 0; d < 1000; d += 100) {
                                    spawnParticles(x + Math.cos(ang)*d, y + Math.sin(ang)*d, 3, '#ff1493');
                                }
                            }, wave * 300);
                        }
                        break;
                    case 'infinityvoid':
                        for (let wave = 0; wave < 15; wave++) {
                            setTimeout(() => {
                                const r = wave * 40;
                                state.explosions.push({ x, y, radius: r, maxRadius: r + 100, life: 0.5, color: '#000033' });
                                spawnParticles(x, y, 10, '#000033');
                            }, wave * 200);
                        }
                        break;
                    case 'starforge':
                        for (let i = 0; i < 5; i++) {
                            const sX = x + Math.cos(i * Math.PI * 0.4) * 300;
                            const sY = y + Math.sin(i * Math.PI * 0.4) * 300;
                            for (let tick = 0; tick < 20; tick++) {
                                setTimeout(() => {
                                    state.explosions.push({ x: sX, y: sY, radius: 50, maxRadius: 150, life: 0.5, color: '#ffdf00' });
                                    spawnParticles(sX, sY, 5, '#ffdf00');
                                }, (i * 500) + (tick * 200));
                            }
                        }
                        break;
                    case 'quantumcollapse':
                        if (data.pts) {
                            for (let i = 0; i < 100; i++) spawnParticles(data.pts[i % 30].x, data.pts[i % 30].y, 1, '#00fff7');
                            for (let wave = 0; wave < 6; wave++) {
                                setTimeout(() => {
                                    for (let j = 0; j < 5; j++) {
                                        const pt = data.pts[(wave*5+j) % 30];
                                        state.explosions.push({ x: pt.x, y: pt.y, radius: 50, maxRadius: 400, life: 1, color: '#00fff7' });
                                    }
                                }, wave * 400);
                            }
                        }
                        break;
                    case 'worldender':
                        // Ring pattern is deterministic from x,y - recreate it
                        for (let ring = 0; ring < 5; ring++) {
                            setTimeout(() => {
                                for (let i = 0; i < 12; i++) {
                                    const ang = (i / 12) * Math.PI * 2;
                                    const r = (ring + 1) * 400;
                                    state.explosions.push({ x: x + Math.cos(ang)*r, y: y + Math.sin(ang)*r, radius: 50, maxRadius: 300, life: 1, color: '#b91c1c' });
                                }
                            }, ring * 250);
                        }
                        break;
                    case 'divinebeam':
                        spawnParticles(x, y, 30, '#f0abfc');
                        break;
                    case 'divinebeamtarget':
                        for (let tick = 0; tick < 10; tick++) {
                            setTimeout(() => {
                                spawnParticles(x, y - tick*30, 5, '#f0abfc');
                                state.explosions.push({ x, y, radius: 10, maxRadius: 60, life: 0.4, color: '#f0abfc' });
                            }, tick * 100);
                        }
                        break;
                    case 'blacksun':
                        state.explosions.push({ x, y, radius: 50, maxRadius: 2000, life: 3, color: '#1c1c1c' });
                        for (let i = 0; i < 10; i++) setTimeout(() => spawnParticles(x, y, 20, '#1c1c1c'), i * 200);
                        break;
                    case 'stormcall':
                        if (data.pts) data.pts.forEach((pt, bolt) => {
                            setTimeout(() => {
                                state.explosions.push({ x: pt.x, y: pt.y, radius: 5, maxRadius: 120, life: 0.4, color: '#60a5fa' });
                                spawnParticles(pt.x, pt.y, 10, '#60a5fa');
                            }, bolt * 150);
                        });
                        break;
                }
            });
        }

        function handleDeath(killerId) {
            state.isDead = true; state.respawnTimer = 3;
            document.getElementById('death-screen').classList.add('active');
            state.omegaUnlocked = false; state.omegaPower = null;
            state.speedActive = false; state.phaseActive = false; state.berserkerActive = false;
            state.mirrorActive = false; state.timestopActive = false; state.clones = []; state.cloneTimer = 0;
            // Reset inventory on death
            state.inventory = [null, null, null];
            state.activeSlot = 0;
            state.inventorySlots = 1;   // need 5 kills again to get 3 slots
            state.killsThisLife = 0;
            state.slotCooldowns = [0, 0, 0];
            state.sprinting = false;
            // Always clear current power on death ‚Äî no power survives respawn
            state.me.currentPower = null; state.me.isOmegaPower = false; state.me.isAdminPower = false;
            // Clear all hit cooldowns so boss/players can re-hit after respawn
            state.hitCooldowns = {};
            updateKillCounter(); updateInventoryUI(); updateScreenEffects();
        }

        function respawn() {
            state.isDead = false;
            document.getElementById('death-screen').classList.remove('active');
            state.me.hp = 100;
            state.me.x = 200 + Math.random() * (CONFIG.map.width - 400);
            state.me.y = 200 + Math.random() * (CONFIG.map.height - 400);
            state.me.currentPower = null; state.me.isOmegaPower = false; state.me.isAdminPower = false;
            state.speedActive = false; state.phaseActive = false; state.berserkerActive = false;
            state.mirrorActive = false; state.timestopActive = false;
            state.hitCooldowns = {};
            state.stamina = 100; state.staminaDepleted = false;
            state.spawnProtection = 3.0; // 3s invincibility after respawn
            updateInventoryUI(); updateScreenEffects();
            spawnParticles(state.me.x, state.me.y, 20, '#00f2fe');
            broadcastState();
        }

        function forceKillPlayer(targetId) {
            if (!state.players[targetId]) return;
            socket.emit('playerDied', { victimId: targetId, killerId: myId });
        }

        function unlockOmega() {
            state.omegaUnlocked = true;
            state.omegaPower = 'meteor';
            document.getElementById('omega-power-name').textContent = OMEGA_POWER.meteor.name;
            document.getElementById('omega-unlock-overlay').classList.add('active');
            setTimeout(() => {
                document.getElementById('omega-unlock-overlay').classList.remove('active');
                showToast(`OMEGA: ${OMEGA_POWER.meteor.name}! Press Q!`, 'omega');
            }, 2500);
            updateKillCounter();
        }

        function updateKillCounter() {
            const threshold = state.nextOmegaThreshold || 10;
            document.getElementById('kill-count').textContent = state.kills;
            const threshEl = document.getElementById('kill-threshold');
            if (threshEl) threshEl.textContent = threshold;
            const counter = document.getElementById('kill-counter');
            const omegaReady = document.getElementById('omega-ready');
            counter.classList.toggle('close-to-omega', state.kills >= threshold - 3 && !state.omegaUnlocked);
            if (state.omegaUnlocked && state.omegaPower) {
                omegaReady.style.display = 'inline';
                omegaReady.textContent = `[Q] ${OMEGA_POWER[state.omegaPower].name}`;
            } else { omegaReady.style.display = 'none'; }
        }

        function loop(timestamp) {
            if (!state.running) return;
            const dt = Math.min((timestamp - state.lastTime) / 1000, 0.1);
            state.lastTime = timestamp;
            if (state.isDead) {
                state.respawnTimer -= dt;
                document.getElementById('respawn-countdown').textContent = Math.ceil(state.respawnTimer);
                if (state.respawnTimer <= 0) respawn();
            } else { 
                update(dt); 
            }
            render();
            requestAnimationFrame(loop);
        }

        function update(dt) {
            if (!state.me) return;
            // Spawn protection countdown
            if (state.spawnProtection > 0) state.spawnProtection = Math.max(0, state.spawnProtection - dt);
            // shootCooldown is now decremented in the movement section below
            if (state.me.poisoned > 0) {
                state.me.poisoned -= dt;
                if (Math.random() < 0.1 && !state.adminGodMode) {
                    state.me.hp -= 1;
                    spawnDamageNumber(state.me.x, state.me.y, 1, 'damage');
                }
            }
            if (state.me.frozen > 0) state.me.frozen -= dt;
            if (state.me.currentPower === 'regeneration' && state.me.hp < 100) {
                state.me.hp = Math.min(100, state.me.hp + dt * 3);
            }
            // Thorns: large thorn growths slow and damage nearby enemies increasingly
            if (state.me.currentPower === 'thorns') {
                const thornRange = 180;
                for (let id in state.players) {
                    const p = state.players[id];
                    const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                    if (dist < thornRange) {
                        // Damage scales with proximity - closer = more damage
                        const intensity = 1 - (dist / thornRange);
                        if (Math.random() < dt * 4 * intensity) {
                            const dmg = Math.max(1, Math.floor(intensity * 8));
                            socket.emit('playerHit', { targetId: id, damage: dmg, attackerId: myId });
                            spawnParticles(
                                state.me.x + (Math.random()-0.5)*thornRange,
                                state.me.y + (Math.random()-0.5)*thornRange,
                                2, '#65a30d'
                            );
                        }
                        // Slow effect: push players that are very close back slightly
                        if (dist < 80 && Math.random() < dt * 3) {
                            socket.emit('playerHit', { targetId: id, damage: 3, attackerId: myId });
                        }
                    }
                }
                // Thorn visual aura particles periodically
                if (Math.random() < dt * 6) {
                    const thornAngle = Math.random() * Math.PI * 2;
                    const thornDist = 60 + Math.random() * 100;
                    spawnParticles(
                        state.me.x + Math.cos(thornAngle) * thornDist,
                        state.me.y + Math.sin(thornAngle) * thornDist,
                        2, '#65a30d'
                    );
                }
            }
            if (state.me.currentPower === 'vampire') {
                for (let id in state.players) {
                    const p = state.players[id];
                    const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                    if (dist < 80 && Math.random() < 0.05) {
                        socket.emit('playerHit', { targetId: id, damage: 3, attackerId: myId });
                        state.me.hp = Math.min(100, state.me.hp + 3);
                        spawnParticles(state.me.x, state.me.y, 3, '#7f1d1d');
                    }
                }
            }
            if (state.omegaTimer > 0) {
                state.omegaTimer -= dt;
                if (state.omegaTimer <= 0) {
                    const wasMirror = state.mirrorActive;
                    state.mirrorActive = false; state.timestopActive = false;
                    showToast(wasMirror ? 'Mirror Shield ended!' : 'Omega ended!', 'warning'); updateScreenEffects();
                }
            }
            if (state.cloneTimer > 0) {
                state.cloneTimer -= dt; updateCloneUI();
                if (state.cloneTimer <= 0) state.clones = [];
            }

            for (let ownerId in state.remoteClones) {
                const clones = state.remoteClones[ownerId];
                const owner = state.players[ownerId];
                if (!owner) { delete state.remoteClones[ownerId]; continue; }
                for (let i = clones.length - 1; i >= 0; i--) {
                    const clone = clones[i];
                    clone.timer -= dt;
                    const orbitDist = 80;
                    const targetX = owner.x - Math.cos(owner.angle + clone.offsetAngle) * orbitDist;
                    const targetY = owner.y - Math.sin(owner.angle + clone.offsetAngle) * orbitDist;
                    clone.x += (targetX - clone.x) * 0.2;
                    clone.y += (targetY - clone.y) * 0.2;
                    clone.angle = owner.angle;
                    clone.name = owner.name; clone.hp = 50; clone.kills = 0; clone.currentPower = 'clone';
                    if (clone.timer <= 0) clones.splice(i, 1);
                }
                if (clones.length === 0) delete state.remoteClones[ownerId];
            }

            for (let i = state.meteors.length - 1; i >= 0; i--) {
                const m = state.meteors[i];
                m.y += m.speed * dt;
                if (m.y >= m.targetY) {
                    state.explosions.push({ x: m.x, y: m.targetY, radius: 20, maxRadius: 100, life: 0.5, color: '#ff4500' });
                    spawnParticles(m.x, m.targetY, 20, '#ff4500');
                    for (let id in state.players) {
                        const p = state.players[id];
                        if (Math.sqrt((m.x - p.x)**2 + (m.targetY - p.y)**2) < 100) {
                            // FIXED: Don't send hit if meteor hits self (checking if hit player is the caster)
                            if (id !== myId) {
                                socket.emit('playerHit', { targetId: id, damage: 40, attackerId: myId });
                            } else {
                                // Self-damage from own meteor (no kill credit should be assigned)
                                socket.emit('playerHit', { targetId: myId, damage: 40, attackerId: null });
                            }
                        }
                    }
                    state.meteors.splice(i, 1);
                }
            }

            state.mouse.worldX = state.mouse.x + state.camera.x;
            state.mouse.worldY = state.mouse.y + state.camera.y;
            const dx = state.mouse.worldX - state.me.x;
            const dy = state.mouse.worldY - state.me.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            state.me.angle = Math.atan2(dy, dx);

            let canMove = state.me.frozen <= 0;
            if (dist > 10 && canMove) {
                let speed = 2.5;
                if (state.me.currentPower === 'speed' && state.speedActive) speed = 5.5;
                if (state.me.currentPower === 'berserker' && state.berserkerActive) speed = 6;
                if (state.me.currentPower === 'tank') speed = 1.5;
                // Sprint boost (Shift held, has stamina)
                const canSprint = state.sprinting && state.stamina > 0 && !state.staminaDepleted;
                if (canSprint) {
                    speed *= 1.65;
                    state.stamina = Math.max(0, state.stamina - dt * 35);
                    // Gray sprint particles behind player
                    if (Math.random() < 0.6) {
                        const backAngle = state.me.angle + Math.PI + (Math.random() - 0.5) * 0.8;
                        const bd = 18 + Math.random() * 14;
                        state.particles.push({
                            x: state.me.x + Math.cos(backAngle) * bd,
                            y: state.me.y + Math.sin(backAngle) * bd,
                            vx: Math.cos(backAngle) * (2 + Math.random() * 3),
                            vy: Math.sin(backAngle) * (2 + Math.random() * 3),
                            life: 0.7, size: Math.random() * 5 + 2,
                            color: `rgba(${170 + Math.floor(Math.random()*50)},${170 + Math.floor(Math.random()*50)},${170 + Math.floor(Math.random()*50)},0.7)`
                        });
                    }
                    // Stamina depleted
                    if (state.stamina <= 0) {
                        state.staminaDepleted = true;
                        state.sprinting = false;
                        state.staminaDepletedTimer = 2.5; // show notification for 2.5s
                        const notif = document.getElementById('stamina-notif');
                        notif.classList.add('visible');
                    }
                } else {
                    // Regen stamina when not sprinting
                    if (!state.sprinting || state.staminaDepleted) {
                        state.stamina = Math.min(100, state.stamina + dt * 18);
                    }
                    // Clear depleted flag once stamina is partially restored
                    if (state.staminaDepleted && state.stamina >= 30) {
                        state.staminaDepleted = false;
                    }
                }
                // Hide stamina notification after timer
                if (state.staminaDepletedTimer > 0) {
                    state.staminaDepletedTimer -= dt;
                    if (state.staminaDepletedTimer <= 0) {
                        document.getElementById('stamina-notif').classList.remove('visible');
                    }
                }
                state.me.x += (dx / dist) * speed;
                state.me.y += (dy / dist) * speed;
                state.me.x = Math.max(25, Math.min(CONFIG.map.width - 25, state.me.x));
                state.me.y = Math.max(25, Math.min(CONFIG.map.height - 25, state.me.y));
            } else {
                // Stationary regen
                state.stamina = Math.min(100, state.stamina + dt * 18);
                if (state.staminaDepleted && state.stamina >= 30) state.staminaDepleted = false;
                if (state.staminaDepletedTimer > 0) {
                    state.staminaDepletedTimer -= dt;
                    if (state.staminaDepletedTimer <= 0) {
                        document.getElementById('stamina-notif').classList.remove('visible');
                    }
                }
            }
            // Update slot cooldowns
            for (let s = 0; s < 3; s++) {
                if (state.slotCooldowns[s] > 0) state.slotCooldowns[s] = Math.max(0, state.slotCooldowns[s] - dt);
            }
            // Legacy shoot cooldown tick (for backward compat)
            if (state.shootCooldown > 0) state.shootCooldown = Math.max(0, state.shootCooldown - dt);
            // Update emote bubble timers
            for (const pid in state.activeEmoteBubbles) {
                state.activeEmoteBubbles[pid].timer -= dt;
                if (state.activeEmoteBubbles[pid].timer <= 0) delete state.activeEmoteBubbles[pid];
            }

            state.clones.forEach((clone, idx) => {
                const followDist = 80 + idx * 50;
                const angleOffset = (idx % 2 === 0 ? 1 : -1) * (Math.PI / 4);
                const targetX = state.me.x - Math.cos(state.me.angle + angleOffset) * followDist;
                const targetY = state.me.y - Math.sin(state.me.angle + angleOffset) * followDist;
                clone.x += (targetX - clone.x) * 0.1;
                clone.y += (targetY - clone.y) * 0.1;
                clone.angle = state.me.angle;
                if (Math.random() < 0.03) {
                    for (let id in state.players) {
                        const p = state.players[id];
                        if (Math.sqrt((clone.x - p.x)**2 + (clone.y - p.y)**2) < 300) {
                            clone.angle = Math.atan2(p.y - clone.y, p.x - clone.x);
                            shootProjectile(clone.x, clone.y, clone.angle, 'basic', 10);
                            break;
                        }
                    }
                }
            });

            for (let id in state.powerups) {
                const p = state.powerups[id];
                if (!p || !p.type || !ALL_POWERS[p.type]) { delete state.powerups[id]; continue; }
                let collectDist = 40;
                if (state.me.currentPower === 'magnet') collectDist = 150;
                const distP = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                if (state.me.currentPower === 'magnet' && distP < 200 && distP > 40) {
                    const pullAngle = Math.atan2(state.me.y - p.y, state.me.x - p.x);
                    p.x += Math.cos(pullAngle) * 3; p.y += Math.sin(pullAngle) * 3;
                }
                // Simulate magnet pull from remote players so all screens look identical
                for (let pid in state.players) {
                    const mp = state.players[pid];
                    if (mp.currentPower !== 'magnet') continue;
                    const mpDist = Math.sqrt((mp.x - p.x)**2 + (mp.y - p.y)**2);
                    if (mpDist < 200 && mpDist > 40) {
                        const mpa = Math.atan2(mp.y - p.y, mp.x - p.x);
                        p.x += Math.cos(mpa) * 3; p.y += Math.sin(mpa) * 3;
                    }
                }
                if (distP < 40) {
                    socket.emit('powerupTaken', { id });
                    const powerType = p.type;
                    const isOmegaOrAdmin = !!(OMEGA_POWER[powerType] || ADMIN_POWERS[powerType]);
                    // Find best slot: active slot if empty, else first empty slot within unlocked range
                    let targetSlot = -1;
                    if (state.inventory[state.activeSlot] === null) {
                        targetSlot = state.activeSlot;
                    } else {
                        for (let s = 0; s < state.inventorySlots; s++) {
                            if (state.inventory[s] === null) { targetSlot = s; break; }
                        }
                    }
                    if (targetSlot === -1) {
                        // All unlocked slots full ‚Äî replace active slot
                        targetSlot = state.activeSlot;
                    }
                    state.inventory[targetSlot] = powerType;
                    state.me.currentPower = state.inventory[state.activeSlot];
                    state.me.isOmegaPower = isOmegaOrAdmin;
                    state.me.isMythicPower = !!(POWERS[powerType] && POWERS[powerType].rarity === 'mythic');
                    state.speedActive = false; state.phaseActive = false; state.berserkerActive = false;
                    updateInventoryUI(); broadcastState();
                    spawnParticles(p.x, p.y, 15, ALL_POWERS[powerType].color);
                    const pInfo = ALL_POWERS[powerType];
                    showToast(`Got ${pInfo.name}!`, pInfo.rarity === 'omega' ? 'omega' : 'mythic');
                    delete state.powerups[id];
                }
            }

            for (let id in state.projectiles) {
                const proj = state.projectiles[id];
                if (proj.localUpdate) {
                    proj.x += Math.cos(proj.angle) * proj.speed * dt;
                    proj.y += Math.sin(proj.angle) * proj.speed * dt;
                    proj.life -= dt;
                    if (proj.owner === myId && !proj.isRemote) {
                        for (let pid in state.players) {
                            const p = state.players[pid];
                            const hitDist = Math.sqrt((p.x - proj.x)**2 + (p.y - proj.y)**2);
                            const hitKey = `${proj.id}_${pid}`;
                            if (hitDist < 28 && !state.hitCooldowns[hitKey]) {
                                state.hitCooldowns[hitKey] = Date.now();
                                let damage = proj.damage || 20;
                                if (state.me.currentPower === 'rage') damage *= 2;
                                socket.emit('playerHit', { targetId: pid, damage, attackerId: myId });
                                spawnParticles(p.x, p.y, 8, '#ef4444');
                                spawnDamageNumber(p.x, p.y, damage, 'damage');
                                if (state.me.currentPower === 'vampire') {
                                    state.me.hp = Math.min(100, state.me.hp + Math.floor(damage * 0.3));
                                }
                                // Explosive: big explosion dealing half damage to all nearby
                                if (proj.type === 'explosive') {
                                    const splashDmg = Math.floor(damage * 0.85);
                                    state.explosions.push({ x: proj.x, y: proj.y, radius: 20, maxRadius: 180, life: 0.8, color: '#f87171' });
                                    for (let i = 0; i < 40; i++) spawnParticles(proj.x, proj.y, 1, ['#f87171','#f59e0b','#ef4444'][Math.floor(Math.random()*3)]);
                                    for (let splashId in state.players) {
                                        if (splashId === pid) continue;
                                        const sp = state.players[splashId];
                                        if (Math.sqrt((proj.x-sp.x)**2+(proj.y-sp.y)**2) < 180) {
                                            socket.emit('playerHit', { targetId: splashId, damage: splashDmg, attackerId: myId });
                                        }
                                    }
                                    emitAbilityEffect('shockwave', proj.x, proj.y);
                                    delete state.projectiles[id]; break;
                                }
                                if (!proj.pierce) { delete state.projectiles[id]; break; }
                            }
                        }
                    }
                    if (proj.isRemote && proj.owner !== myId) {
                        const hitDist = Math.sqrt((state.me.x - proj.x)**2 + (state.me.y - proj.y)**2);
                        const hitKey = `${proj.id}_me`;
                        if (hitDist < 28 && !state.hitCooldowns[hitKey] && !state.adminGodMode && !state.isDead) {
                            state.hitCooldowns[hitKey] = Date.now();
                            if (state.me.currentPower === 'phase' && state.phaseActive) {
                            } else if (state.mirrorActive) {
                                socket.emit('playerHit', { targetId: proj.owner, damage: proj.damage, attackerId: myId });
                                spawnParticles(state.me.x, state.me.y, 10, '#c0c0c0');
                            } else {
                                let damage = proj.damage || 20;
                                if (state.me.currentPower === 'shield') damage = Math.floor(damage * 0.5);
                                if (state.me.currentPower === 'tank') damage = Math.floor(damage * 0.25);
                                state.me.hp -= damage;
                                spawnDamageNumber(state.me.x, state.me.y, damage, 'damage');
                                spawnParticles(state.me.x, state.me.y, 10, '#ef4444');
                                if (state.me.currentPower === 'thorns') {
                                    socket.emit('playerHit', { targetId: proj.owner, damage: Math.floor(damage * 0.3), attackerId: myId });
                                }
                                if (state.me.hp <= 0 && !state.isDead) {
                                    state.isDead = true;
                                    socket.emit('playerDied', { victimId: myId, killerId: proj.owner });
                                }
                            }
                            if (!proj.pierce) delete state.projectiles[id];
                        }
                    }
                    if (proj.life <= 0 || proj.x < 0 || proj.x > CONFIG.map.width || proj.y < 0 || proj.y > CONFIG.map.height) {
                        delete state.projectiles[id];
                    }
                }
            }

            // ‚îÄ‚îÄ NPC interpolation + hit detection (in update, not render) ‚îÄ‚îÄ
            for (const npcId in state.npcs) {
                const npc = state.npcs[npcId];
                if (!npc) continue;
                // Smooth movement using dt so NPCs glide instead of snap
                if (npc.targetX !== undefined) {
                    npc.x = (npc.x !== undefined ? npc.x : npc.targetX);
                    npc.y = (npc.y !== undefined ? npc.y : npc.targetY);
                    npc.x += (npc.targetX - npc.x) * Math.min(1, dt * 8);
                    npc.y += (npc.targetY - npc.y) * Math.min(1, dt * 8);
                }
                if (!npc.rarity || (npc.hp !== undefined && npc.hp <= 0)) continue;
                // Hit detection ‚Äî runs here so projectiles are guaranteed to be valid
                for (const pid in state.projectiles) {
                    const proj = state.projectiles[pid];
                    if (!proj || proj.owner !== myId || proj.isRemote) continue;
                    const npcRadius = NPC_RADII[npc.rarity] || 20;
                    const hitDist = Math.sqrt((npc.x - proj.x) ** 2 + (npc.y - proj.y) ** 2);
                    const hitKey = 'npc_' + npcId + '_' + pid;
                    if (hitDist < npcRadius + 10 && !state.hitCooldowns[hitKey]) {
                        state.hitCooldowns[hitKey] = Date.now();
                        const dmg = proj.damage || 20;
                        npc.hp = Math.max(0, (npc.hp || 0) - dmg); // optimistic update
                        socket.emit('npcHit', { npcId, damage: dmg });
                        spawnParticles(npc.x, npc.y, 6, NPC_COLORS[npc.rarity] || '#fff');
                        spawnDamageNumber(npc.x, npc.y, dmg, 'damage');
                        if (!proj.pierce) { delete state.projectiles[pid]; break; }
                    }
                }
            }

            const now = Date.now();
            for (let key in state.hitCooldowns) {
                if (now - state.hitCooldowns[key] > 500) delete state.hitCooldowns[key];
            }
            broadcastState();
            state.camera.x += (state.me.x - canvas.width / 2 - state.camera.x) * 0.1;
            state.camera.y += (state.me.y - canvas.height / 2 - state.camera.y) * 0.1;

            for (let i = state.particles.length - 1; i >= 0; i--) {
                const p = state.particles[i];
                p.life -= dt * 2; p.x += p.vx; p.y += p.vy; p.vx *= 0.98; p.vy *= 0.98;
                if (p.life <= 0) state.particles.splice(i, 1);
            }
            for (let i = state.explosions.length - 1; i >= 0; i--) {
                const e = state.explosions[i];
                e.life -= dt * 2; e.radius += dt * 200;
                if (e.life <= 0) state.explosions.splice(i, 1);
            }
            // Update timebomb timers
            for (let i = state.timebombs.length - 1; i >= 0; i--) {
                state.timebombs[i].timer -= dt;
                if (state.timebombs[i].timer <= -1) state.timebombs.splice(i, 1);
            }
            for (let id in state.players) {
                const p = state.players[id];
                if (p.targetX !== undefined && !state.timestopActive) {
                    p.x += (p.targetX - p.x) * 0.2; p.y += (p.targetY - p.y) * 0.2;
                }
            }
            if (state.me.recoil > 0) state.me.recoil -= dt * 30;
            if (Math.random() < 0.1) updateLeaderboard();
            updateInventoryUI(); // update cooldown display every frame
            
            // Baby update
            if (state.baby) {
                state.baby.targetX = state.mouse.worldX;
                state.baby.targetY = state.mouse.worldY;
                const bDx = state.baby.targetX - state.baby.x;
                const bDy = state.baby.targetY - state.baby.y;
                const bDist = Math.sqrt(bDx*bDx + bDy*bDy);
                if (bDist > 15) {
                    state.baby.x += (bDx/bDist) * 3.5;
                    state.baby.y += (bDy/bDist) * 3.5;
                    state.baby.angle = Math.atan2(bDy, bDx);
                }
                // Baby shoots at nearest enemy
                state.babyShootCooldown -= dt;
                if (state.babyShootCooldown <= 0) {
                    state.babyShootCooldown = 0.6;
                    let closest = null, closestDist = 200;
                    for (let id in state.players) {
                        const p = state.players[id];
                        const d = Math.sqrt((state.baby.x-p.x)**2+(state.baby.y-p.y)**2);
                        if (d < closestDist) { closestDist = d; closest = { id, ...p }; }
                    }
                    if (closest) {
                        const shootAngle = Math.atan2(closest.y - state.baby.y, closest.x - state.baby.x);
                        const bProjId = 'baby_' + (projectileIdCounter++);
                        state.projectiles[bProjId] = {
                            id: bProjId, x: state.baby.x, y: state.baby.y, angle: shootAngle,
                            type: 'basic', damage: 8, speed: 500, owner: myId,
                            color: '#ff69b4', life: 2, localUpdate: true, isRemote: false, isBaby: true
                        };
                        socket.emit('shoot', { x: state.baby.x, y: state.baby.y, angle: shootAngle, type: 'basic', damage: 8, speed: 500, color: '#ff69b4' });
                    }
                }
                // Baby can be killed by others being close
                for (let id in state.players) {
                    const p = state.players[id];
                    if (Math.sqrt((state.baby.x-p.x)**2+(state.baby.y-p.y)**2) < 30) {
                        if (Math.random() < dt * 2) {
                            state.baby.hp -= 5;
                            spawnParticles(state.baby.x, state.baby.y, 5, '#ef4444');
                        }
                    }
                }
                if (state.baby.hp <= 0) {
                    state.explosions.push({ x: state.baby.x, y: state.baby.y, radius: 20, maxRadius: 100, life: 0.6, color: '#ff69b4' });
                    spawnParticles(state.baby.x, state.baby.y, 30, '#ff69b4');
                    socket.emit('abilityUsed', { type: 'babydied', x: state.baby.x, y: state.baby.y, id: myId });
                    state.baby = null;
                    document.getElementById('baby-controls').classList.remove('visible');
                    showToast('Baby was killed!', 'error');
                } else {
                    const hpPct = state.baby.hp / 50;
                    document.getElementById('baby-hp-fill').style.width = (hpPct*100)+'%';
                    document.getElementById('baby-hp-text').textContent = state.baby.hp;
                    // Broadcast baby position to all other players (~10x per second)
                    if (!state.babyBroadcastTimer) state.babyBroadcastTimer = 0;
                    state.babyBroadcastTimer -= dt;
                    if (state.babyBroadcastTimer <= 0) {
                        state.babyBroadcastTimer = 0.1;
                        socket.emit('abilityUsed', { type: 'babypos', x: state.baby.x, y: state.baby.y, id: myId, angle: state.baby.angle, hp: state.baby.hp });
                    }
                }
            }
        }

        function shootProjectile(x, y, angle, type, damage = 20) {
            const id = 'local_' + (projectileIdCounter++);
            const info = ALL_POWERS[type] || { color: '#00f2fe' };
            let speed = 600;
            if (type === 'sniper') { speed = 1200; damage = 60; }
            if (type === 'minigun') { speed = 700; }
            if (type === 'laser') damage = 15;
            state.projectiles[id] = {
                id, x, y, angle, type, damage, speed, owner: myId,
                color: info.color || '#00f2fe', pierce: type === 'laser',
                life: 3, localUpdate: true, isRemote: false
            };
            spawnParticles(x, y, 5, info.color || '#00f2fe');
            if (socket) {
                socket.emit('shoot', { x, y, angle, type, damage, speed, color: info.color || '#00f2fe' });
            }
        }

        function render() {
            ctx.fillStyle = CONFIG.colors.grid;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(-state.camera.x, -state.camera.y);
            drawGrid();
            for (let e of state.explosions) {
                ctx.globalAlpha = e.life * 0.6; ctx.fillStyle = e.color;
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2); ctx.fill();
            }
            ctx.globalAlpha = 1;
            for (let m of state.meteors) {
                ctx.fillStyle = '#ff4500'; ctx.shadowBlur = 20; ctx.shadowColor = '#ff4500';
                ctx.beginPath(); ctx.arc(m.x, m.y, 15, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            }
            for (let id in state.powerups) {
                const p = state.powerups[id];
                if (p && p.type && ALL_POWERS[p.type]) drawPowerup(p);
            }
            // Draw active timebombs - same small pulsing indicator on all screens
            for (let bomb of state.timebombs) {
                if (bomb.timer <= 0) continue;
                const pulse = Math.sin(Date.now() / 120) * 0.4 + 0.6;
                const urgency = 1 - (bomb.timer / 2.0);
                ctx.save();
                ctx.globalAlpha = pulse;
                ctx.fillStyle = '#ff6b00'; ctx.shadowBlur = 12 + urgency * 20; ctx.shadowColor = '#ff6b00';
                ctx.beginPath(); ctx.arc(bomb.x, bomb.y, 8 + urgency * 6, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 0.4 * pulse;
                ctx.strokeStyle = '#ff6b00'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(bomb.x, bomb.y, 18 + urgency * 10, 0, Math.PI * 2); ctx.stroke();
                ctx.shadowBlur = 0; ctx.restore();
                ctx.save();
                ctx.fillStyle = 'white'; ctx.font = 'bold 11px Outfit'; ctx.textAlign = 'center';
                ctx.shadowColor = '#ff6b00'; ctx.shadowBlur = 6;
                ctx.fillText(Math.ceil(bomb.timer) + 's', bomb.x, bomb.y - 22);
                ctx.restore();
            }
            for (let id in state.projectiles) {
                const p = state.projectiles[id];
                const projRadius = p.type === 'explosive' ? 12 : (p.type === 'minigun' ? 4 : 6);
                ctx.fillStyle = p.color || '#00f2fe'; ctx.shadowBlur = 8; ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath(); ctx.arc(p.x, p.y, projRadius, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            }
            // Draw laser beams (visible to all)
            for (let i = state.laserBeams.length - 1; i >= 0; i--) {
                const lb = state.laserBeams[i];
                lb.life -= 0.04;
                if (lb.life <= 0) { state.laserBeams.splice(i, 1); continue; }
                ctx.save();
                ctx.globalAlpha = lb.life;
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 8 * lb.life;
                ctx.shadowBlur = 20; ctx.shadowColor = '#ef4444';
                ctx.beginPath();
                ctx.moveTo(lb.x1, lb.y1);
                ctx.lineTo(lb.x2, lb.y2);
                ctx.stroke();
                ctx.lineWidth = 3 * lb.life; ctx.strokeStyle = '#ffaaaa';
                ctx.beginPath(); ctx.moveTo(lb.x1, lb.y1); ctx.lineTo(lb.x2, lb.y2); ctx.stroke();
                ctx.shadowBlur = 0; ctx.restore();
            }
            // Draw rocket trails (visible to all)
            for (let i = state.rocketTrails.length - 1; i >= 0; i--) {
                const rt = state.rocketTrails[i];
                rt.life -= 0.05;
                if (rt.life <= 0) { state.rocketTrails.splice(i, 1); continue; }
                ctx.save();
                ctx.globalAlpha = rt.life * 0.8;
                ctx.fillStyle = '#fb923c'; ctx.shadowBlur = 12; ctx.shadowColor = '#fb923c';
                ctx.beginPath(); ctx.arc(rt.x, rt.y, 8 * rt.life, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                ctx.restore();
            }
            for (let clone of state.clones) drawPlayer(clone, false, true);
            for (let ownerId in state.remoteClones) {
                for (let clone of state.remoteClones[ownerId]) drawPlayer(clone, false, true);
            }
            // Draw NPCs
            for (const npcId in state.npcs) {
                const npc = state.npcs[npcId];
                if (!npc || !npc.rarity || (npc.hp !== undefined && npc.hp <= 0)) continue;
                drawNPC(npc);
            }
            for (let id in state.players) {
                if (state.players[id].hp > 0) drawPlayer(state.players[id], false, false);
            }
            if (state.me && !state.isDead) drawPlayer(state.me, true, false);
            // Draw emote bubbles above players
            drawEmoteBubbles();
            // Draw baby
            if (state.baby) {
                ctx.save();
                ctx.translate(state.baby.x, state.baby.y);
                ctx.rotate(state.baby.angle);
                ctx.fillStyle = '#ff69b4'; ctx.shadowBlur = 10; ctx.shadowColor = '#ff69b4';
                ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath(); ctx.arc(5, -3, 2, 0, Math.PI * 2); ctx.arc(5, 3, 2, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
                // Baby HP bar and label
                ctx.save();
                ctx.translate(state.baby.x, state.baby.y);
                ctx.fillStyle = 'white'; ctx.font = 'bold 9px Outfit'; ctx.textAlign = 'center';
                ctx.shadowColor = 'black'; ctx.shadowBlur = 3;
                ctx.fillText('BABY', 0, -22);
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath(); ctx.roundRect(-15, -18, 30, 4, 2); ctx.fill();
                ctx.fillStyle = '#ff69b4';
                ctx.beginPath(); ctx.roundRect(-15, -18, 30*(state.baby.hp/50), 4, 2); ctx.fill();
                ctx.restore();
            }
            // Draw remote babies (from other players)
            for (let ownerId in state.remoteBabies) {
                const rb = state.remoteBabies[ownerId];
                if (!rb) continue;
                ctx.save();
                ctx.translate(rb.x, rb.y);
                ctx.rotate(rb.angle || 0);
                ctx.fillStyle = '#ff69b4'; ctx.shadowBlur = 10; ctx.shadowColor = '#ff69b4';
                ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath(); ctx.arc(5, -3, 2, 0, Math.PI * 2); ctx.arc(5, 3, 2, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
                ctx.save();
                ctx.translate(rb.x, rb.y);
                ctx.fillStyle = 'white'; ctx.font = 'bold 9px Outfit'; ctx.textAlign = 'center';
                ctx.shadowColor = 'black'; ctx.shadowBlur = 3;
                ctx.fillText('BABY', 0, -22);
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath(); ctx.roundRect(-15, -18, 30, 4, 2); ctx.fill();
                ctx.fillStyle = '#ff69b4';
                ctx.beginPath(); ctx.roundRect(-15, -18, 30 * ((rb.hp || 50) / 50), 4, 2); ctx.fill();
                ctx.restore();
            }
            for (let p of state.particles) {
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Draw all Bosses
            for (const bossId in state.bosses) {
                const boss = state.bosses[bossId];
                if (!boss) continue;
                // Smooth movement
                if (boss.targetX !== undefined) {
                    boss.x = (boss.x || boss.targetX) + ((boss.targetX - (boss.x || boss.targetX)) * 0.15);
                    boss.y = (boss.y || boss.targetY) + ((boss.targetY - (boss.y || boss.targetY)) * 0.15);
                }
                const bx = boss.x, by = boss.y;
                const bHpPct = Math.max(0, (boss.hp || 0) / (boss.maxHp || 1000));
                ctx.save();
                ctx.translate(bx, by);
                const bAura = Math.sin(Date.now() / 150) * 15 + 50;
                const bGrad = ctx.createRadialGradient(0, 0, 20, 0, 0, bAura + 30);
                bGrad.addColorStop(0, 'rgba(255,0,0,0.4)');
                bGrad.addColorStop(1, 'rgba(80,0,0,0)');
                ctx.fillStyle = bGrad;
                ctx.beginPath(); ctx.arc(0, 0, bAura + 30, 0, Math.PI * 2); ctx.fill();
                ctx.rotate(boss.angle || 0);
                ctx.fillStyle = '#b91c1c'; ctx.shadowBlur = 30; ctx.shadowColor = '#ff0000';
                ctx.beginPath(); ctx.arc(0, 0, 42, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                for (let i = 0; i < 8; i++) {
                    const sa = (i / 8) * Math.PI * 2 + Date.now() / 500;
                    ctx.fillStyle = '#7f1d1d';
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(sa) * 40, Math.sin(sa) * 40);
                    ctx.lineTo(Math.cos(sa + 0.2) * 62, Math.sin(sa + 0.2) * 62);
                    ctx.lineTo(Math.cos(sa - 0.2) * 62, Math.sin(sa - 0.2) * 62);
                    ctx.fill();
                }
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath(); ctx.arc(14, -12, 8, 0, Math.PI * 2); ctx.arc(14, 12, 8, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(17, -12, 4, 0, Math.PI * 2); ctx.arc(17, 12, 4, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
                ctx.save();
                ctx.translate(bx, by);
                ctx.fillStyle = '#ff4444'; ctx.font = 'bold 18px Outfit'; ctx.textAlign = 'center';
                ctx.shadowColor = '#000'; ctx.shadowBlur = 5;
                ctx.fillText(`[BOSS] ${boss.label || ''}`, 0, -70);
                ctx.font = 'bold 13px Outfit'; ctx.fillStyle = '#fbbf24';
                ctx.fillText(`${Math.round(boss.hp || 0)} / ${boss.maxHp || 1000} HP`, 0, -53);
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath(); ctx.roundRect(-50, -45, 100, 8, 4); ctx.fill();
                ctx.fillStyle = bHpPct > 0.5 ? '#ef4444' : (bHpPct > 0.25 ? '#f59e0b' : '#dc2626');
                ctx.beginPath(); ctx.roundRect(-50, -45, 100 * bHpPct, 8, 4); ctx.fill();
                ctx.restore();
                // Boss hit detection for projectiles
                for (let id in state.projectiles) {
                    const proj = state.projectiles[id];
                    if (proj.owner !== myId || proj.isRemote) continue;
                    const hitDist = Math.sqrt((bx - proj.x) ** 2 + (by - proj.y) ** 2);
                    const hitKey = `boss_${bossId}_${proj.id}`;
                    if (hitDist < 50 && !state.hitCooldowns[hitKey]) {
                        state.hitCooldowns[hitKey] = Date.now();
                        socket.emit('bossHit', { bossId, damage: proj.damage || 20, attackerId: myId });
                        spawnParticles(bx, by, 10, '#ff4444');
                        spawnDamageNumber(bx, by, proj.damage || 20, 'damage');
                        if (!proj.pierce) delete state.projectiles[id];
                    }
                }
            }

            ctx.restore();
        }

        function drawGrid() {
            const gridSize = 100;
            const startX = Math.floor(state.camera.x / gridSize) * gridSize;
            const startY = Math.floor(state.camera.y / gridSize) * gridSize;
            ctx.strokeStyle = CONFIG.colors.gridLine; ctx.lineWidth = 2; ctx.beginPath();
            for (let x = startX; x < startX + canvas.width + gridSize; x += gridSize) {
                if (x >= 0 && x <= CONFIG.map.width) {
                    ctx.moveTo(x, Math.max(0, startY));
                    ctx.lineTo(x, Math.min(CONFIG.map.height, startY + canvas.height + gridSize));
                }
            }
            for (let y = startY; y < startY + canvas.height + gridSize; y += gridSize) {
                if (y >= 0 && y <= CONFIG.map.height) {
                    ctx.moveTo(Math.max(0, startX), y);
                    ctx.lineTo(Math.min(CONFIG.map.width, startX + canvas.width + gridSize), y);
                }
            }
            ctx.stroke();
            ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, CONFIG.map.width, CONFIG.map.height);
        }

        function drawPlayer(p, isMe, isClone) {
            if (!p || p.hp <= 0) return;
            if (isClone) ctx.globalAlpha = 0.7;
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.save();
            ctx.fillStyle = isClone ? '#14b8a6' : 'white';
            ctx.font = 'bold 14px Outfit'; ctx.textAlign = 'center';
            ctx.shadowColor = 'black'; ctx.shadowBlur = 4;

            // Draw OWNER crown tag above name for admin
            const isOwnerPlayer = p.isOwner || (isMe && isAdmin);
            if (isOwnerPlayer) {
                // Crown glow
                ctx.save();
                const ownerPulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                ctx.shadowBlur = 12; ctx.shadowColor = '#ffd700';
                ctx.fillStyle = `rgba(255,215,0,${ownerPulse})`;
                ctx.font = 'bold 10px Outfit';
                ctx.fillText('üëë OWNER', 0, -68);
                ctx.restore();
            }

            ctx.fillText(p.name || 'Player', 0, -50);
            const kills = isMe ? state.kills : (p.kills || 0);
            ctx.fillStyle = kills >= 10 ? '#ffd700' : 'rgba(255,255,255,0.7)';
            ctx.font = 'bold 11px Outfit';
            ctx.fillText(`${kills} kills`, 0, -38);
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath(); ctx.roundRect(-25, -30, 50, 6, 3); ctx.fill();
            const hpPct = Math.max(0, (p.hp || 100) / 100);
            ctx.fillStyle = hpPct > 0.5 ? '#10b981' : '#ef4444';
            ctx.beginPath(); ctx.roundRect(-25, -30, 50 * hpPct, 6, 3); ctx.fill();
            ctx.restore();
            ctx.rotate(p.angle || 0);
            const power = p.currentPower;
            const powerDef = ALL_POWERS[power];
            if (power === 'shield') {
                ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 3;
                ctx.shadowBlur = 15; ctx.shadowColor = '#3b82f6';
                ctx.beginPath(); ctx.arc(0, 0, 36, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur = 0;
            }
            if (power === 'tank') {
                ctx.strokeStyle = '#374151'; ctx.lineWidth = 5;
                ctx.beginPath(); ctx.arc(0, 0, 34, 0, Math.PI * 2); ctx.stroke();
            }
            if (power === 'phase' && (isMe ? state.phaseActive : p.phaseActive)) {
                ctx.strokeStyle = 'rgba(167,139,250,0.6)'; ctx.lineWidth = 2; ctx.setLineDash([8,4]);
                ctx.beginPath(); ctx.arc(0, 0, 38, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]);
            }
            if (power === 'berserker' && (isMe ? state.berserkerActive : p.berserkerActive)) {
                for (let i = 0; i < 8; i++) {
                    const ang = (i / 8) * Math.PI * 2 + Date.now() / 200;
                    ctx.fillStyle = `rgba(220,38,38,${0.5 + Math.random() * 0.3})`;
                    ctx.beginPath(); ctx.arc(Math.cos(ang) * 30, Math.sin(ang) * 30, 4, 0, Math.PI * 2); ctx.fill();
                }
            }
            if (power === 'speed' && (isMe ? state.speedActive : p.speedActive)) {
                ctx.strokeStyle = 'rgba(239,68,68,0.6)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, 35, 0, Math.PI * 2); ctx.stroke();
            }
            if (power === 'vampire') {
                const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.5;
                ctx.strokeStyle = `rgba(127,29,29,${pulse})`; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(0, 0, 35, 0, Math.PI * 2); ctx.stroke();
            }
            if (power === 'thorns') {
                // Draw thorn spike aura around player
                const now = Date.now();
                for (let i = 0; i < 12; i++) {
                    const spikeAngle = (i / 12) * Math.PI * 2 + now / 1500;
                    const spikeLen = 22 + Math.sin(now / 300 + i) * 6;
                    ctx.strokeStyle = 'rgba(101,163,13,0.75)'; ctx.lineWidth = 2;
                    ctx.shadowBlur = 6; ctx.shadowColor = '#65a30d';
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(spikeAngle) * 24, Math.sin(spikeAngle) * 24);
                    ctx.lineTo(Math.cos(spikeAngle) * (24 + spikeLen), Math.sin(spikeAngle) * (24 + spikeLen));
                    ctx.stroke(); ctx.shadowBlur = 0;
                }
                ctx.strokeStyle = 'rgba(101,163,13,0.4)'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(0, 0, 180, 0, Math.PI * 2); ctx.stroke();
            }
            if (power === 'poison') {
                const pulseP = Math.sin(Date.now() / 400) * 0.3 + 0.5;
                ctx.strokeStyle = `rgba(132,204,22,${pulseP})`; ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.stroke();
                ctx.setLineDash([]);
            }
            if (power === 'phoenix') {
                const pp = Math.sin(Date.now() / 180) * 0.4 + 0.6;
                ctx.strokeStyle = `rgba(255,102,0,${pp})`; ctx.lineWidth = 3;
                ctx.shadowBlur = 20; ctx.shadowColor = '#ff6600';
                ctx.beginPath(); ctx.arc(0, 0, 38, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur = 0;
                for (let i = 0; i < 6; i++) {
                    const fa = (i / 6) * Math.PI * 2 + Date.now() / 600;
                    ctx.fillStyle = `rgba(255,${100 + Math.floor(Math.sin(Date.now()/300+i)*80)},0,0.5)`;
                    ctx.beginPath(); ctx.arc(Math.cos(fa)*30, Math.sin(fa)*30, 5, 0, Math.PI*2); ctx.fill();
                }
            }
            if (power === 'soulsteal') {
                const sp = Math.sin(Date.now() / 220) * 0.3 + 0.6;
                ctx.strokeStyle = `rgba(136,0,255,${sp})`; ctx.lineWidth = 3;
                ctx.shadowBlur = 20; ctx.shadowColor = '#8800ff';
                ctx.beginPath(); ctx.arc(0, 0, 37, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur = 0;
            }
            if (isMe && state.mirrorActive || (!isMe && p.mirrorActive)) {
                ctx.strokeStyle = '#c0c0c0'; ctx.lineWidth = 3;
                ctx.shadowBlur = 20; ctx.shadowColor = '#c0c0c0';
                ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur = 0;
            }
            const recoil = (isMe && state.me?.recoil) ? state.me.recoil : 0;
            ctx.fillStyle = '#94a3b8';
            ctx.beginPath(); ctx.arc(16 - recoil, -15, 8, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(16 - recoil, 15, 8, 0, Math.PI * 2); ctx.fill();
            let bodyColor = powerDef ? powerDef.color : (isMe ? '#00f2fe' : '#ef4444');
            if (isClone) bodyColor = '#14b8a6';
            if (isMe && state.adminGodMode) bodyColor = '#ff00ff';
            ctx.fillStyle = bodyColor;
            if (isMe || isClone) { ctx.shadowBlur = 15; ctx.shadowColor = bodyColor; }
            ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath(); ctx.arc(10, -7, 4, 0, Math.PI * 2); ctx.arc(10, 7, 4, 0, Math.PI * 2); ctx.fill();
            // Spawn protection shield ring
            if (isMe && state.spawnProtection > 0) {
                const pulse = Math.sin(Date.now() / 120) * 4;
                ctx.save();
                ctx.strokeStyle = `rgba(0,255,180,${0.4 + Math.sin(Date.now()/200)*0.3})`;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 14; ctx.shadowColor = '#00ffb4';
                ctx.beginPath(); ctx.arc(0, 0, 30 + pulse, 0, Math.PI * 2); ctx.stroke();
                ctx.restore();
            }
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        function drawNPC(npc) {
            const color = NPC_COLORS[npc.rarity] || '#9ca3af';
            const r = NPC_RADII[npc.rarity] || 20;
            const hpMax = { common:60, rare:150, epic:320, legendary:750, mythic:1500 }[npc.rarity] || 100;
            const hpPct = Math.max(0, Math.min(1, (npc.hp || 0) / hpMax));
            ctx.save();
            ctx.translate(npc.x, npc.y);
            // Aura glow
            const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
            if (npc.rarity === 'mythic' || npc.rarity === 'legendary') {
                const auraR = r + 20 + Math.sin(Date.now()/200)*8;
                const grad = ctx.createRadialGradient(0,0,r,0,0,auraR);
                const hexToRgba = (hex, a) => { const n = parseInt(hex.slice(1), 16); return `rgba(${(n>>16)&255},${(n>>8)&255},${n&255},${a})`; };
                grad.addColorStop(0, hexToRgba(color, 0.35));
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = color + '44';
                ctx.beginPath(); ctx.arc(0,0,auraR,0,Math.PI*2); ctx.fill();
            }
            // Body
            ctx.shadowBlur = npc.rarity === 'mythic' ? 25 : (npc.rarity === 'legendary' ? 18 : 10);
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.rotate(npc.angle || 0);
            if (npc.rarity === 'mythic') {
                // Star-shaped
                ctx.beginPath();
                for (let i=0;i<10;i++) {
                    const ang = (i/10)*Math.PI*2 - Math.PI/2;
                    const rad = i%2===0 ? r : r*0.5;
                    if(i===0) ctx.moveTo(Math.cos(ang)*rad, Math.sin(ang)*rad);
                    else ctx.lineTo(Math.cos(ang)*rad, Math.sin(ang)*rad);
                }
                ctx.closePath(); ctx.fill();
            } else if (npc.rarity === 'legendary') {
                // Diamond
                ctx.beginPath();
                ctx.moveTo(0,-r); ctx.lineTo(r,0); ctx.lineTo(0,r); ctx.lineTo(-r,0);
                ctx.closePath(); ctx.fill();
            } else {
                ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
            }
            ctx.shadowBlur = 0;
            // Eyes
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.beginPath(); ctx.arc(r*0.45,-r*0.25,r*0.22,0,Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(r*0.45,r*0.25,r*0.22,0,Math.PI*2); ctx.fill();
            ctx.restore();
            // Labels above
            ctx.save();
            ctx.translate(npc.x, npc.y);
            const rarityLabel = { common:'COMMON', rare:'RARE', epic:'EPIC', legendary:'LEGENDARY', mythic:'MYTHIC' }[npc.rarity] || '';
            ctx.fillStyle = color; ctx.font = 'bold 9px Outfit'; ctx.textAlign = 'center';
            ctx.shadowColor = '#000'; ctx.shadowBlur = 4;
            ctx.fillText(rarityLabel, 0, -r-24);
            ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.font = 'bold 9px Outfit';
            ctx.fillText(Math.round(npc.hp||0)+'/'+hpMax+' HP', 0, -r-12);
            // HP bar
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath(); ctx.roundRect(-25,-r-8,50,5,3); ctx.fill();
            ctx.fillStyle = hpPct>0.5 ? '#10b981' : (hpPct>0.25 ? '#f59e0b' : '#ef4444');
            ctx.beginPath(); ctx.roundRect(-25,-r-8,50*hpPct,5,3); ctx.fill();
            ctx.restore();
        }

        function drawEmoteBubbles() {
            // Draw emote bubble for local player
            if (state.me && !state.isDead && state.activeEmoteBubbles['__me__']) {
                const b = state.activeEmoteBubbles['__me__'];
                drawEmoteBubble(state.me.x, state.me.y, b.emote);
            }
            // Draw remote players' emotes
            for (const pid in state.activeEmoteBubbles) {
                if (pid === '__me__') continue;
                const p = state.players[pid];
                if (!p || p.hp <= 0) continue;
                drawEmoteBubble(p.x, p.y, state.activeEmoteBubbles[pid].emote);
            }
        }

        function drawEmoteBubble(x, y, emoteKey) {
            ctx.save();
            ctx.translate(x, y - 70);
            ctx.fillStyle = 'rgba(10,10,20,0.88)';
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.roundRect(-18,-18,36,36,10);
            ctx.fill(); ctx.stroke();
            // Tail
            ctx.fillStyle = 'rgba(10,10,20,0.88)';
            ctx.beginPath(); ctx.moveTo(-5,16); ctx.lineTo(5,16); ctx.lineTo(0,24); ctx.closePath(); ctx.fill();
            // Draw SVG icon
            const img = EMOTE_IMGS[emoteKey];
            if (img && img.complete && img.naturalWidth > 0) {
                ctx.drawImage(img, -13, -13, 26, 26);
            } else {
                // Fallback: draw a question mark
                ctx.fillStyle = '#00f2fe'; ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('?', 0, 0);
            }
            ctx.restore();
        }

        function drawPowerup(p) {
            const info = ALL_POWERS[p.type];
            if (!info) return;
            const bounce = Math.sin(Date.now() / 250) * 4;
            const rarityColor = RARITY_COLORS[info.rarity] || '#9ca3af';
            ctx.save();
            ctx.translate(p.x, p.y + bounce);
            if (info.rarity === 'omega') {
                const pulse = Math.sin(Date.now() / 150) * 10 + 30;
                const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, pulse);
                gradient.addColorStop(0, 'rgba(255,215,0,0.4)');
                gradient.addColorStop(1, 'rgba(255,107,0,0)');
                ctx.fillStyle = gradient;
                ctx.beginPath(); ctx.arc(0, 0, pulse, 0, Math.PI * 2); ctx.fill();
            }
            if (info.rarity === 'mythic') {
                const pulse = Math.sin(Date.now() / 120) * 12 + 32;
                const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, pulse);
                gradient.addColorStop(0, 'rgba(255,0,204,0.5)');
                gradient.addColorStop(1, 'rgba(51,0,255,0)');
                ctx.fillStyle = gradient;
                ctx.beginPath(); ctx.arc(0, 0, pulse, 0, Math.PI * 2); ctx.fill();
            }
            ctx.shadowBlur = 20; ctx.shadowColor = rarityColor;
            ctx.strokeStyle = rarityColor; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI * 2); ctx.stroke();
            ctx.fillStyle = info.color;
            ctx.beginPath(); ctx.arc(0, 0, 16, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            ctx.fillStyle = 'white'; ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(info.name.charAt(0), 0, 0);
            ctx.restore();
        }

        function spawnParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                state.particles.push({
                    x, y, vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12,
                    life: 1.0, size: Math.random() * 4 + 2, color
                });
            }
        }

        function spawnDamageNumber(x, y, damage, type = 'damage') {
            const dmgEl = document.createElement('div');
            dmgEl.className = `dmg-num ${type}`;
            dmgEl.textContent = type === 'heal' ? `+${damage}` : `-${damage}`;
            dmgEl.style.left = (x - state.camera.x) + 'px';
            dmgEl.style.top = (y - state.camera.y - 50) + 'px';
            document.getElementById('damage-numbers').appendChild(dmgEl);
            setTimeout(() => dmgEl.remove(), 1000);
        }

        function updateInventoryUI() {
            for (let s = 0; s < 3; s++) {
                const slotEl = document.getElementById(`inv-slot-${s}`);
                const canvasEl = document.getElementById(`inv-canvas-${s}`);
                const badgeEl = document.getElementById(`inv-badge-${s}`);
                const hintEl = document.getElementById(`inv-hint-${s}`);
                const lockEl = document.getElementById(`inv-lock-${s}`);
                const isUnlocked = s < state.inventorySlots;
                const power = state.inventory[s];
                const isActive = s === state.activeSlot;
                // Lock/unlock appearance
                slotEl.classList.toggle('locked-slot', !isUnlocked);
                slotEl.classList.toggle('active-slot', isActive && isUnlocked);
                if (!isUnlocked) {
                    if (lockEl) lockEl.style.display = 'block';
                    if (canvasEl) canvasEl.style.display = 'none';
                    badgeEl.style.display = 'none';
                    hintEl.textContent = '';
                    slotEl.style.borderColor = '';
                    continue;
                }
                if (lockEl) lockEl.style.display = 'none';
                if (canvasEl) canvasEl.style.display = 'block';
                if (!power || !ALL_POWERS[power]) {
                    const cx = canvasEl.getContext('2d');
                    cx.clearRect(0, 0, 44, 44);
                    badgeEl.style.display = 'none';
                    hintEl.textContent = 'Empty';
                    slotEl.style.borderColor = isActive ? 'var(--primary)' : '';
                    slotEl.classList.remove('speed-active', 'omega-active');
                    continue;
                }
                const info = ALL_POWERS[power];
                const cx = canvasEl.getContext('2d');
                cx.clearRect(0, 0, 44, 44);
                cx.fillStyle = info.color; cx.shadowBlur = 8; cx.shadowColor = info.color;
                cx.beginPath(); cx.arc(22, 22, 17, 0, Math.PI * 2); cx.fill(); cx.shadowBlur = 0;
                cx.fillStyle = 'white'; cx.font = 'bold 12px Arial';
                cx.textAlign = 'center'; cx.textBaseline = 'middle';
                cx.fillText(info.name.charAt(0), 22, 22);
                badgeEl.style.display = 'block';
                badgeEl.textContent = info.type === 'admin' ? 'admin' : info.rarity;
                badgeEl.style.color = RARITY_COLORS[info.rarity];
                badgeEl.classList.toggle('omega', info.rarity === 'omega' || info.rarity === 'admin' || info.rarity === 'mythic');
                hintEl.textContent = `${info.name}`;
                slotEl.style.borderColor = isActive ? info.color : rgba_dim(info.color, 0.4);
                slotEl.classList.toggle('omega-active', isActive && (info.rarity === 'omega' || info.rarity === 'admin' || info.rarity === 'mythic'));
                slotEl.classList.toggle('speed-active', isActive && (state.speedActive || state.phaseActive || state.berserkerActive));
            }
            // Update cooldown overlays
            for (let s = 0; s < 3; s++) {
                const cdEl = document.getElementById(`inv-cd-${s}`);
                const cdText = document.getElementById(`inv-cd-text-${s}`);
                const cd = state.slotCooldowns ? state.slotCooldowns[s] : 0;
                if (cd > 0.05) {
                    cdEl.classList.add('active');
                    cdText.textContent = cd.toFixed(1) + 's';
                } else {
                    cdEl.classList.remove('active');
                }
            }
        }

        function rgba_dim(hex, alpha) {
            // Convert hex color to rgba for dimming
            try {
                const r = parseInt(hex.slice(1,3),16);
                const g = parseInt(hex.slice(3,5),16);
                const b = parseInt(hex.slice(5,7),16);
                return `rgba(${r},${g},${b},${alpha})`;
            } catch(e) { return hex; }
        }

        // Legacy compat ‚Äî called from various places
        function updatePowerUI(type) {
            if (state.me && type !== undefined) {
                state.inventory[state.activeSlot] = type;
                state.me.currentPower = type;
            }
            updateInventoryUI();
        }

        function updateSpeedUI() {
            updateInventoryUI();
        }

        function updateCloneUI() {
            const timer = document.getElementById('clone-timer');
            const fill = document.getElementById('clone-timer-fill');
            const label = document.getElementById('clone-timer-label');
            if (state.cloneTimer > 0) {
                timer.style.display = 'block'; label.style.display = 'block';
                fill.style.width = (state.cloneTimer / state.cloneMaxTime) * 100 + '%';
            } else { timer.style.display = 'none'; label.style.display = 'none'; }
        }

        function updateScreenEffects() {
            const effects = document.getElementById('screen-effects');
            effects.innerHTML = '';
            if (state.timestopActive) effects.innerHTML += '<div class="timestop-effect"></div>';
            if (state.mirrorActive) effects.innerHTML += '<div class="mirror-effect"></div>';
        }

        function updateLeaderboard() {
            const list = Object.values(state.players).map(p => ({ name: p.name, kills: p.kills || 0, id: p.id }));
            if (state.me) list.push({ name: state.me.name, kills: state.kills, id: myId });
            list.sort((a, b) => b.kills - a.kills);
            document.getElementById('lb-content').innerHTML = list.slice(0, 5).map(p => `
                <div class="lb-row ${p.id === myId ? 'me' : ''}">
                    <span>${escapeHtml(p.name)}</span><span>${p.kills}</span>
                </div>
            `).join('');
        }

        function escapeHtml(t) { return t ? t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;") : ''; }

        window.openModal = id => document.getElementById(id).style.display = 'flex';
        window.closeModal = id => document.getElementById(id).style.display = 'none';

        window.showToast = function(msg, type = 'info') {
            const el = document.createElement('div');
            el.className = `toast ${type}`;
            el.innerHTML = `<span>${msg}</span>`;
            document.getElementById('toast-container').appendChild(el);
            setTimeout(() => { el.classList.add('toast-exit'); setTimeout(() => el.remove(), 300); }, 2500);
        };

        window.addEventListener('mousemove', e => { state.mouse.x = e.clientX; state.mouse.y = e.clientY; });

        window.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                if (e.code === 'Enter' && e.target.id === 'chat-input') sendChat();
                return;
            }
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                state.sprinting = true; return;
            }
            if (state.isDead) return;
            if (e.code === 'Space') { e.preventDefault(); tryPower(); }
            if (e.code === 'KeyD') { e.preventDefault(); tryDrop(); }
            if (e.code === 'KeyQ') { e.preventDefault(); tryOmegaPower(); }
            if (e.code === 'Enter') document.getElementById('chat-input').focus();
            if (e.code === 'Digit1') selectSlot(0);
            if (e.code === 'Digit2') selectSlot(1);
            if (e.code === 'Digit3') selectSlot(2);
            if (e.code === 'KeyE') { e.preventDefault(); if (state.running && !state.isDead) toggleEmoteWheel(); }
        });

        window.addEventListener('keyup', e => {
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                state.sprinting = false;
            }
        });

        // ‚îÄ‚îÄ EMOTE SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function toggleEmoteWheel() {
            if (!state.running) return;
            state.emoteWheelOpen = !state.emoteWheelOpen;
            const wheel = document.getElementById('emote-wheel');
            if (state.emoteWheelOpen) wheel.classList.add('visible');
            else wheel.classList.remove('visible');
        }

        function useEmote(slotIdx) {
            if (!state.me || state.isDead) return;
            const emote = state.equippedEmotes[slotIdx];
            if (!emote) return;
            // Show locally above our own player
            state.activeEmoteBubbles['__me__'] = { emote, timer: 3.0 };
            // Broadcast to others
            if (socket) socket.emit('useEmote', { emote });
            // Close wheel
            state.emoteWheelOpen = false;
            document.getElementById('emote-wheel').classList.remove('visible');
        }

        function renderEmoteShop() {
            const grid = document.getElementById('emote-shop-grid');
            if (!grid) return;
            grid.innerHTML = '';
            EMOTE_CATALOG.forEach((em, idx) => {
                const div = document.createElement('div');
                div.className = 'emote-shop-item' + (state.equippedEmotes.includes(em.key) ? ' equipped' : '');
                div.innerHTML = '<span class="emote-icon">'+EMOTE_SVG_STRS[em.key]+'</span><div class="emote-name">'+em.name+'</div><span class="emote-badge">FREE</span>';
                div.onclick = () => toggleEquipEmote(em.key);
                grid.appendChild(div);
            });
            updateEquippedDisplay();
        }

        function toggleEquipEmote(emoji) {
            const idx = state.equippedEmotes.indexOf(emoji);
            if (idx >= 0) {
                // Unequip
                state.equippedEmotes.splice(idx, 1);
            } else if (state.equippedEmotes.length < 4) {
                // Equip
                state.equippedEmotes.push(emoji);
            } else {
                // Replace first
                state.equippedEmotes.shift();
                state.equippedEmotes.push(emoji);
            }
            updateEquippedDisplay();
            renderEmoteShop();
            updateEmoteWheelBtns();
        }

        function updateEquippedDisplay() {
            for (let i = 0; i < 4; i++) {
                const el = document.getElementById('eq-slot-'+i);
                if (el) {
                    const key = state.equippedEmotes[i];
                    el.innerHTML = key && EMOTE_SVG_STRS[key] ? EMOTE_SVG_STRS[key] : '<span style="color:rgba(255,255,255,0.4);font-size:1.1rem">‚Äî</span>';
                }
            }
        }

        function updateEmoteWheelBtns() {
            for (let i = 0; i < 4; i++) {
                const btn = document.getElementById('emote-slot-'+i);
                if (btn) {
                    const key = state.equippedEmotes[i];
                    btn.innerHTML = key && EMOTE_SVG_STRS[key] ? EMOTE_SVG_STRS[key] : '';
                }
            }
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        // Periodically clean up stale NPC hit cooldowns (older than 10s)
        setInterval(() => {
            const now = Date.now();
            for (const key in state.hitCooldowns) {
                if (typeof state.hitCooldowns[key] === 'number' && now - state.hitCooldowns[key] > 10000) {
                    delete state.hitCooldowns[key];
                }
            }
        }, 15000);

        function selectSlot(idx) {
            if (!state.me || idx >= state.inventorySlots) return;
            state.activeSlot = idx;
            state.me.currentPower = state.inventory[idx] || null;
            state.speedActive = false; state.phaseActive = false; state.berserkerActive = false;
            updateInventoryUI();
            broadcastState();
        }

        function tryDamageBoss(cx, cy, radius, damage) {
            for (const bossId in state.bosses) {
                const b = state.bosses[bossId];
                if (!b || !b.x) continue;
                const d = Math.sqrt((cx - b.x)**2 + (cy - b.y)**2);
                if (d < radius) {
                    socket.emit('bossHit', { bossId, damage, attackerId: myId });
                    spawnParticles(b.x, b.y, 15, '#ff4444');
                    spawnDamageNumber(b.x, b.y, damage, 'damage');
                }
            }
        }

        function tryDamageNPCs(cx, cy, radius, damage) {
            for (const npcId in state.npcs) {
                const npc = state.npcs[npcId];
                if (!npc || !npc.rarity || (npc.hp !== undefined && npc.hp <= 0)) continue;
                const d = Math.sqrt((cx - npc.x)**2 + (cy - npc.y)**2);
                if (d < radius) {
                    npc.hp = Math.max(0, (npc.hp || 0) - damage);
                    socket.emit('npcHit', { npcId, damage });
                    spawnParticles(npc.x, npc.y, 6, '#ff4444');
                    spawnDamageNumber(npc.x, npc.y, damage, 'damage');
                }
            }
        }

        function tryOmegaPower() {
            if (!state.me || !state.omegaUnlocked || !state.omegaPower) {
                const threshold = state.nextOmegaThreshold || 10;
                showToast(`No Omega! Get ${threshold} kills.`, 'warning'); return;
            }
            const powerInfo = OMEGA_POWER[state.omegaPower];
            // Only meteor is the omega power for players now
            if (state.omegaPower === 'meteor') {
                const targetX = state.mouse.worldX;
                const targetY = state.mouse.worldY;
                for (let i = 0; i < 8; i++) {
                    const offsetX = (Math.random() - 0.5) * 300;
                    const offsetY = -400 - Math.random() * 200;
                    state.meteors.push({
                        x: targetX + offsetX, y: targetY + offsetY,
                        targetY: targetY, speed: 800
                    });
                }
                spawnParticles(targetX, targetY, 50, '#ff4500');
                emitAbilityEffect('meteor', targetX, targetY);
                showToast('METEOR STRIKE!', 'omega');
                tryDamageBoss(targetX, targetY, 500, 120);
                state.omegaUnlocked = false;
                state.omegaPower = null;
                // Advance the threshold by 10 so next omega requires 10 more kills
                state.nextOmegaThreshold = (state.nextOmegaThreshold || 10) + 10;
                updateKillCounter();
            }
        }

        function tryPower() {
            if (!state.me || !state.me.currentPower || !ALL_POWERS[state.me.currentPower]) {
                showToast('No power!', 'warning'); return;
            }
            const powerType = state.me.currentPower;
            const powerInfo = ALL_POWERS[powerType];
            if (powerInfo.type === 'passive') { showToast(`${powerInfo.name} is always active!`, 'mythic'); return; }
            if (powerInfo.type === 'toggle') {
                if (powerType === 'speed') state.speedActive = !state.speedActive;
                else if (powerType === 'phase') state.phaseActive = !state.phaseActive;
                else if (powerType === 'berserker') state.berserkerActive = !state.berserkerActive;
                updateSpeedUI(); broadcastState();
                showToast(`${powerInfo.name}: ${state.speedActive || state.phaseActive || state.berserkerActive ? 'ON' : 'OFF'}`, 'mythic');
                return;
            }
            if (powerInfo.type === 'shoot') {
                // Updated cooldowns
                let cooldown = 0.15;
                if (powerType === 'minigun') cooldown = 0.2;
                if (powerType === 'sniper') cooldown = 6.0;
                if (powerType === 'voidbeam') cooldown = 1.5;
                if (powerType === 'tripleshot') cooldown = 1.5;
                if (powerType === 'scatter') cooldown = 1.5;
                if (powerType === 'explosive') cooldown = 1.5;
                if (powerType === 'freeze') cooldown = 1.5;
                if (state.adminInfinite) cooldown = 0.02;
                if (state.slotCooldowns[state.activeSlot] <= 0) {
                    const shootX = state.me.x + Math.cos(state.me.angle) * 25;
                    const shootY = state.me.y + Math.sin(state.me.angle) * 25;
                    let damage = 20;
                    if (powerType === 'sniper') damage = 60;
                    if (powerType === 'explosive') damage = 17;
                    if (powerType === 'voidbeam') damage = 50;
                    if (powerType === 'tripleshot') {
                        for (let i = -1; i <= 1; i++) shootProjectile(shootX, shootY, state.me.angle + i * 0.2, powerType, damage);
                    } else if (powerType === 'scatter') {
                        for (let i = 0; i < 8; i++) shootProjectile(state.me.x, state.me.y, (i / 8) * Math.PI * 2, powerType, 15);
                    } else if (powerType === 'voidbeam') {
                        for (let i = -2; i <= 2; i++) {
                            shootProjectile(shootX, shootY, state.me.angle + i * 0.05, powerType, damage);
                        }
                    } else { shootProjectile(shootX, shootY, state.me.angle, powerType, damage); }
                    state.me.recoil = powerType === 'sniper' ? 15 : 8;
                    state.slotCooldowns[state.activeSlot] = cooldown;
                    state.shootCooldown = cooldown; // legacy compat
                }
                return;
            }
            let used = false;
            switch (powerType) {
                case 'dash':
                    const oldPos = { x: state.me.x, y: state.me.y };
                    state.me.x += Math.cos(state.me.angle) * 150;
                    state.me.y += Math.sin(state.me.angle) * 150;
                    state.me.x = Math.max(25, Math.min(CONFIG.map.width - 25, state.me.x));
                    state.me.y = Math.max(25, Math.min(CONFIG.map.height - 25, state.me.y));
                    spawnParticles(oldPos.x, oldPos.y, 15, '#f59e0b');
                    spawnParticles(state.me.x, state.me.y, 15, '#f59e0b');
                    emitAbilityEffect('dash', oldPos.x, oldPos.y);
                    emitAbilityEffect('dash', state.me.x, state.me.y);
                    showToast('Dashed!', 'mythic'); used = true; break;
                case 'teleport':
                    spawnParticles(state.me.x, state.me.y, 20, '#10b981');
                    emitAbilityEffect('teleport', state.me.x, state.me.y);
                    state.me.x = Math.max(50, Math.min(CONFIG.map.width - 50, state.mouse.worldX));
                    state.me.y = Math.max(50, Math.min(CONFIG.map.height - 50, state.mouse.worldY));
                    spawnParticles(state.me.x, state.me.y, 20, '#10b981');
                    emitAbilityEffect('teleport', state.me.x, state.me.y);
                    showToast('Warped!', 'mythic'); used = true; break;
                case 'poison':
                    // Poison aura: drains nearby enemies to ~5 HP over time but won't kill
                    const poisonX = state.me.x, poisonY = state.me.y;
                    state.explosions.push({ x: poisonX, y: poisonY, radius: 10, maxRadius: 180, life: 1.5, color: '#84cc16' });
                    spawnParticles(poisonX, poisonY, 40, '#84cc16');
                    socket.emit('abilityUsed', { type: 'poison', x: poisonX, y: poisonY, id: myId });
                    let poisonInterval = 0;
                    const poisonTick = setInterval(() => {
                        poisonInterval++;
                        for (let id in state.players) {
                            const p = state.players[id];
                            const dist = Math.sqrt((poisonX - p.x)**2 + (poisonY - p.y)**2);
                            if (dist < 200) {
                                const currentHp = p.hp || 100;
                                if (currentHp > 8) {
                                    socket.emit('playerHit', { targetId: id, damage: 6, attackerId: myId });
                                    spawnParticles(p.x, p.y, 3, '#84cc16');
                                }
                            }
                        }
                        // Self - apply poison tick visual
                        for (let i = 0; i < 5; i++) {
                            spawnParticles(
                                poisonX + (Math.random()-0.5)*180,
                                poisonY + (Math.random()-0.5)*180,
                                1, '#84cc16'
                            );
                        }
                        // Broadcast poison tick so others see the ongoing effect
                        socket.emit('abilityUsed', { type: 'poisontick', x: poisonX, y: poisonY, id: myId });
                        if (poisonInterval >= 8) clearInterval(poisonTick);
                        tryDamageBoss(poisonX, poisonY, 200, 6);
                        tryDamageNPCs(poisonX, poisonY, 200, 6);
                    }, 300);
                    showToast('Poison Aura!', 'mythic'); used = true; break;
                case 'laser':
                    // Continuous laser beam for ~1 second ‚Äî fires in facing direction
                    const laserAngle = state.me.angle;
                    const laserStartX = state.me.x, laserStartY = state.me.y;
                    const laserEndX = laserStartX + Math.cos(laserAngle)*1200;
                    const laserEndY = laserStartY + Math.sin(laserAngle)*1200;
                    // Add beam to local render list
                    state.laserBeams.push({ x1: laserStartX, y1: laserStartY, x2: laserEndX, y2: laserEndY, life: 1 });
                    // Emit so others can see (must use 'abilityUsed' ‚Äî server re-broadcasts as 'abilityEffect')
                    socket.emit('abilityUsed', { type: 'laserbeam', x: laserStartX, y: laserStartY, x2: laserEndX, y2: laserEndY, id: myId });
                    let laserTick = 0, laserDmgDealt = {};
                    spawnParticles(laserStartX, laserStartY, 20, '#ef4444');
                    const laserFire = setInterval(() => {
                        laserTick++;
                        state.laserBeams.push({ x1: laserStartX, y1: laserStartY, x2: laserEndX, y2: laserEndY, life: 1 });
                        socket.emit('abilityUsed', { type: 'laserbeam', x: laserStartX, y: laserStartY, x2: laserEndX, y2: laserEndY, id: myId });
                        // Trace beam and hit players along it
                        for (let id in state.players) {
                            const p = state.players[id];
                            const dx = p.x - laserStartX, dy = p.y - laserStartY;
                            const t = dx * Math.cos(laserAngle) + dy * Math.sin(laserAngle);
                            if (t > 0 && t < 1200) {
                                const perpX = p.x - (laserStartX + Math.cos(laserAngle)*t);
                                const perpY = p.y - (laserStartY + Math.sin(laserAngle)*t);
                                const perpDist = Math.sqrt(perpX*perpX + perpY*perpY);
                                if (perpDist < 30) {
                                    const alreadyHit = laserDmgDealt[id] || 0;
                                    if (alreadyHit < 50) {
                                        const dmg = 8;
                                        socket.emit('playerHit', { targetId: id, damage: dmg, attackerId: myId });
                                        laserDmgDealt[id] = alreadyHit + dmg;
                                        spawnParticles(p.x, p.y, 5, '#ef4444');
                                    }
                                }
                            }
                        }
                        // Laser also damages boss along its path
                        tryDamageBoss(laserStartX + Math.cos(laserAngle)*600, laserStartY + Math.sin(laserAngle)*600, 500, 8);
                        // Laser damages NPCs along its path
                        for (const npcId in state.npcs) {
                            const npc = state.npcs[npcId];
                            if (!npc || !npc.rarity || (npc.hp !== undefined && npc.hp <= 0)) continue;
                            const ndx = npc.x - laserStartX, ndy = npc.y - laserStartY;
                            const nt = ndx * Math.cos(laserAngle) + ndy * Math.sin(laserAngle);
                            if (nt > 0 && nt < 1200) {
                                const perpX = npc.x - (laserStartX + Math.cos(laserAngle)*nt);
                                const perpY = npc.y - (laserStartY + Math.sin(laserAngle)*nt);
                                if (Math.sqrt(perpX*perpX + perpY*perpY) < 30) {
                                    npc.hp = Math.max(0, (npc.hp || 0) - 8);
                                    socket.emit('npcHit', { npcId, damage: 8 });
                                    spawnParticles(npc.x, npc.y, 3, '#ef4444');
                                }
                            }
                        }
                        if (laserTick >= 8) clearInterval(laserFire);
                    }, 125);
                    showToast('LASER BEAM!', 'mythic'); used = true; break;
                case 'rocket':
                    // Rocket form: dash in facing direction, leave fire trail damaging nearby enemies
                    const rocketAngle = state.me.angle;
                    const rocketStartX = state.me.x, rocketStartY = state.me.y;
                    emitAbilityEffect('dash', rocketStartX, rocketStartY);
                    let rocketStep = 0;
                    const rocketInterval = setInterval(() => {
                        rocketStep++;
                        const prevX = state.me.x, prevY = state.me.y;
                        state.me.x += Math.cos(rocketAngle) * 55;
                        state.me.y += Math.sin(rocketAngle) * 55;
                        state.me.x = Math.max(25, Math.min(CONFIG.map.width-25, state.me.x));
                        state.me.y = Math.max(25, Math.min(CONFIG.map.height-25, state.me.y));
                        // Fire trail local + remote (must use 'abilityUsed' ‚Äî server re-broadcasts as 'abilityEffect')
                        spawnParticles(prevX, prevY, 8, '#fb923c');
                        spawnParticles(prevX, prevY, 4, '#fbbf24');
                        state.rocketTrails.push({ x: prevX, y: prevY, life: 1 });
                        socket.emit('abilityUsed', { type: 'rockettrail', x: prevX, y: prevY, id: myId });
                        // Damage nearby enemies during dash
                        for (let id in state.players) {
                            const p = state.players[id];
                            const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                            if (dist < 100) socket.emit('playerHit', { targetId: id, damage: 15, attackerId: myId });
                        }
                        tryDamageBoss(state.me.x, state.me.y, 130, 15);
                        tryDamageNPCs(state.me.x, state.me.y, 130, 15);
                        state.explosions.push({ x: prevX, y: prevY, radius: 10, maxRadius: 80, life: 0.4, color: '#fb923c' });
                        broadcastState();
                        if (rocketStep >= 6) {
                            clearInterval(rocketInterval);
                            spawnParticles(state.me.x, state.me.y, 30, '#fb923c');
                            state.rocketTrails.push({ x: state.me.x, y: state.me.y, life: 1.5 });
                            state.explosions.push({ x: state.me.x, y: state.me.y, radius: 20, maxRadius: 150, life: 0.7, color: '#fb923c' });
                            socket.emit('abilityUsed', { type: 'rockettrail', x: state.me.x, y: state.me.y, id: myId });
                        }
                    }, 60);
                    showToast('ROCKET LAUNCH!', 'mythic'); used = true; break;
                case 'clone':
                    for (let i = 0; i < 3; i++) {
                        const angleOffset = (i - 1) * (Math.PI / 3);
                        state.clones.push({
                            x: state.me.x - Math.cos(state.me.angle + angleOffset) * 60,
                            y: state.me.y - Math.sin(state.me.angle + angleOffset) * 60,
                            angle: state.me.angle, name: state.me.name, hp: 50, kills: 0, currentPower: 'clone'
                        });
                    }
                    state.cloneTimer = state.cloneMaxTime;
                    spawnParticles(state.me.x, state.me.y, 40, '#14b8a6');
                    emitAbilityEffect('clone', state.me.x, state.me.y);
                    showToast('Clones!', 'mythic'); updateCloneUI(); used = true; break;
                case 'heal':
                    state.me.hp = Math.min(100, state.me.hp + 50);
                    spawnParticles(state.me.x, state.me.y, 20, '#22c55e');
                    spawnDamageNumber(state.me.x, state.me.y, 50, 'heal');
                    emitAbilityEffect('heal', state.me.x, state.me.y);
                    showToast('Healed!', 'mythic'); used = true; break;
                case 'shockwave':
                    for (let id in state.players) {
                        const p = state.players[id];
                        if (Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2) < 200) {
                            socket.emit('playerHit', { targetId: id, damage: 25, attackerId: myId });
                        }
                    }
                    tryDamageBoss(state.me.x, state.me.y, 200, 25);
                    tryDamageNPCs(state.me.x, state.me.y, 200, 25);
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 30, maxRadius: 200, life: 0.5, color: '#8b5cf6' });
                    emitAbilityEffect('shockwave', state.me.x, state.me.y);
                    showToast('Shockwave!', 'mythic'); used = true; break;
                case 'blackhole':
                    state.explosions.push({ x: state.mouse.worldX, y: state.mouse.worldY, radius: 10, maxRadius: 200, life: 1.5, color: '#1e1b4b' });
                    for (let id in state.players) {
                        const p = state.players[id];
                        if (Math.sqrt((state.mouse.worldX - p.x)**2 + (state.mouse.worldY - p.y)**2) < 200) {
                            socket.emit('playerHit', { targetId: id, damage: 30, attackerId: myId });
                        }
                    }
                    spawnParticles(state.mouse.worldX, state.mouse.worldY, 40, '#4c1d95');
                    emitAbilityEffect('blackhole', state.mouse.worldX, state.mouse.worldY);
                    tryDamageBoss(state.mouse.worldX, state.mouse.worldY, 200, 30);
                    tryDamageNPCs(state.mouse.worldX, state.mouse.worldY, 200, 30);
                    showToast('Blackhole!', 'mythic'); used = true; break;
                case 'nuke':
                    for (let id in state.players) {
                        const p = state.players[id];
                        if (Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2) < 400) {
                            socket.emit('playerHit', { targetId: id, damage: 70, attackerId: myId });
                        }
                    }
                    tryDamageBoss(state.me.x, state.me.y, 400, 70);
                    tryDamageNPCs(state.me.x, state.me.y, 400, 70);
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 50, maxRadius: 400, life: 1, color: '#dc2626' });
                    for (let i = 0; i < 60; i++) spawnParticles(state.me.x, state.me.y, 1, ['#dc2626', '#f59e0b', '#fbbf24'][Math.floor(Math.random() * 3)]);
                    emitAbilityEffect('nuke', state.me.x, state.me.y);
                    showToast('NUKE!', 'mythic'); used = true; break;
                case 'emp':
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 30, maxRadius: 250, life: 0.8, color: '#6366f1' });
                    spawnParticles(state.me.x, state.me.y, 30, '#6366f1');
                    emitAbilityEffect('emp', state.me.x, state.me.y);
                    tryDamageBoss(state.me.x, state.me.y, 250, 20);
                    tryDamageNPCs(state.me.x, state.me.y, 250, 20);
                    showToast('EMP!', 'mythic'); used = true; break;
                case 'swap':
                    let nearest = null, nearestDist = 500;
                    for (let id in state.players) {
                        const p = state.players[id];
                        const d = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                        if (d < nearestDist) { nearestDist = d; nearest = { id, ...p }; }
                    }
                    if (nearest) {
                        const myOldX = state.me.x;
                        const myOldY = state.me.y;
                        spawnParticles(state.me.x, state.me.y, 20, '#ec4899');
                        emitAbilityEffect('swap', state.me.x, state.me.y);
                        // Move me to target's position
                        state.me.x = nearest.x; state.me.y = nearest.y;
                        // Tell server to force-move the target to my old position
                        socket.emit('swapPositions', { targetId: nearest.id, myOldX, myOldY });
                        // Visually update target on our end immediately
                        if (state.players[nearest.id]) {
                            state.players[nearest.id].x = myOldX;
                            state.players[nearest.id].y = myOldY;
                            state.players[nearest.id].targetX = myOldX;
                            state.players[nearest.id].targetY = myOldY;
                        }
                        spawnParticles(state.me.x, state.me.y, 20, '#ec4899');
                        spawnParticles(myOldX, myOldY, 20, '#ec4899');
                        emitAbilityEffect('swap', state.me.x, state.me.y);
                        showToast('Swapped!', 'mythic'); used = true;
                    } else { showToast('No enemy nearby!', 'warning'); }
                    break;
                // NEW REGULAR POWERS - ACTUALLY UNIQUE
                case 'timebomb':
                    const bombX = state.mouse.worldX;
                    const bombY = state.mouse.worldY;
                    // Add to timebombs list - renders as small pulsing indicator on ALL screens
                    const bombId = 'bomb_' + Date.now();
                    state.timebombs.push({ id: bombId, x: bombX, y: bombY, timer: 2.0 });
                    spawnParticles(bombX, bombY, 20, '#ff6b00');
                    // Broadcast the bomb placement + scheduled explosion so all clients see it
                    socket.emit('abilityUsed', { type: 'timebomb', x: bombX, y: bombY, id: myId, bombId });
                    setTimeout(() => {
                        state.explosions.push({ x: bombX, y: bombY, radius: 30, maxRadius: 250, life: 0.8, color: '#ff6b00' });
                        for (let id in state.players) {
                            const p = state.players[id];
                            if (Math.sqrt((bombX - p.x)**2 + (bombY - p.y)**2) < 250) {
                                socket.emit('playerHit', { targetId: id, damage: 50, attackerId: myId });
                            }
                        }
                        tryDamageBoss(bombX, bombY, 250, 50);
                        tryDamageNPCs(bombX, bombY, 250, 50);
                        for (let i = 0; i < 40; i++) spawnParticles(bombX, bombY, 1, '#ff6b00');
                        socket.emit('abilityUsed', { type: 'timebombexplode', x: bombX, y: bombY, id: myId, bombId });
                        // Remove from local timebombs
                        const bi = state.timebombs.findIndex(b => b.id === bombId);
                        if (bi !== -1) state.timebombs.splice(bi, 1);
                    }, 2000);
                    showToast('Bomb planted! 2 seconds...', 'mythic'); used = true; break;
                case 'orbitallaser':
                    const targetX = state.mouse.worldX;
                    const targetY = state.mouse.worldY;
                    // Laser warning - emit for all
                    socket.emit('abilityUsed', { type: 'orbitallaser', x: targetX, y: targetY, id: myId });
                    for (let i = 0; i < 30; i++) {
                        spawnParticles(targetX + (Math.random()-0.5)*100, -50, 1, '#00f5ff');
                    }
                    setTimeout(() => {
                        // Giant laser from sky
                        for (let i = 0; i < 100; i++) {
                            const laserY = i * 50;
                            spawnParticles(targetX, laserY, 2, '#00f5ff');
                        }
                        state.explosions.push({ x: targetX, y: targetY, radius: 40, maxRadius: 200, life: 1, color: '#00f5ff' });
                        socket.emit('abilityUsed', { type: 'orbitallaserfire', x: targetX, y: targetY, id: myId });
                        for (let id in state.players) {
                            const p = state.players[id];
                            if (Math.sqrt((targetX - p.x)**2 + (targetY - p.y)**2) < 200) {
                                socket.emit('playerHit', { targetId: id, damage: 70, attackerId: myId });
                            }
                        }
                        tryDamageBoss(targetX, targetY, 200, 70);
                        tryDamageNPCs(targetX, targetY, 200, 70);
                    }, 1500);
                    showToast('Orbital strike incoming!', 'mythic'); used = true; break;
                case 'shadowclone':
                    const shadowX = state.me.x - Math.cos(state.me.angle) * 100;
                    const shadowY = state.me.y - Math.sin(state.me.angle) * 100;
                    spawnParticles(shadowX, shadowY, 30, '#1a1a2e');
                    socket.emit('abilityUsed', { type: 'shadowclone', x: shadowX, y: shadowY, id: myId });
                    setTimeout(() => {
                        state.explosions.push({ x: shadowX, y: shadowY, radius: 30, maxRadius: 180, life: 0.6, color: '#1a1a2e' });
                        socket.emit('abilityUsed', { type: 'shadowcloneexplode', x: shadowX, y: shadowY, id: myId });
                        for (let id in state.players) {
                            const p = state.players[id];
                            if (Math.sqrt((shadowX - p.x)**2 + (shadowY - p.y)**2) < 180) {
                                socket.emit('playerHit', { targetId: id, damage: 45, attackerId: myId });
                            }
                        }
                        tryDamageBoss(shadowX, shadowY, 180, 45);
                        tryDamageNPCs(shadowX, shadowY, 180, 45);
                    }, 1000);
                    showToast('Shadow decoy!', 'mythic'); used = true; break;
                case 'frostnova':
                    for (let id in state.players) {
                        const p = state.players[id];
                        const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                        if (dist < 300) {
                            socket.emit('playerHit', { targetId: id, damage: 35, attackerId: myId });
                        }
                    }
                    tryDamageBoss(state.me.x, state.me.y, 300, 35);
                    tryDamageNPCs(state.me.x, state.me.y, 300, 35);
                    for (let i = 0; i < 50; i++) {
                        const angle = (i / 50) * Math.PI * 2;
                        const dist = 50 + Math.random() * 250;
                        spawnParticles(state.me.x + Math.cos(angle)*dist, state.me.y + Math.sin(angle)*dist, 3, '#a5f3fc');
                    }
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 40, maxRadius: 300, life: 1, color: '#a5f3fc' });
                    socket.emit('abilityUsed', { type: 'frostnova', x: state.me.x, y: state.me.y, id: myId });
                    showToast('Frost Nova!', 'mythic'); used = true; break;
                case 'soulrip':
                    // Tear souls of all nearby enemies to your location, damage them and heal yourself
                    const soulRadius = 380;
                    let soulsCaught = 0;
                    spawnParticles(state.me.x, state.me.y, 60, '#7c00ff');
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 20, maxRadius: soulRadius, life: 1.2, color: '#7c00ff' });
                    socket.emit('abilityUsed', { type: 'soulrip', x: state.me.x, y: state.me.y, id: myId });
                    for (let id in state.players) {
                        const p = state.players[id];
                        const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                        if (dist < soulRadius) {
                            soulsCaught++;
                            // Rip them toward you visually
                            spawnParticles(p.x, p.y, 20, '#a855f7');
                            // Damage
                            socket.emit('playerHit', { targetId: id, damage: 35, attackerId: myId });
                            // Move them toward caster on their client (use swap mechanics)
                            const pullAngle = Math.atan2(state.me.y - p.y, state.me.x - p.x);
                            const pullX = p.x + Math.cos(pullAngle) * Math.min(dist * 0.7, 250);
                            const pullY = p.y + Math.sin(pullAngle) * Math.min(dist * 0.7, 250);
                            socket.emit('swapPositions', { targetId: id, myOldX: pullX, myOldY: pullY });
                            if (state.players[id]) {
                                state.players[id].targetX = pullX;
                                state.players[id].targetY = pullY;
                            }
                        }
                    }
                    // Heal self based on souls caught
                    if (soulsCaught > 0) {
                        const healAmount = soulsCaught * 8;
                        state.me.hp = Math.min(100, state.me.hp + healAmount);
                        spawnDamageNumber(state.me.x, state.me.y, healAmount, 'heal');
                    }
                    tryDamageBoss(state.me.x, state.me.y, soulRadius, 35);
                    tryDamageNPCs(state.me.x, state.me.y, soulRadius, 35);
                    showToast(`SOUL RIP! (${soulsCaught} souls torn)`, 'mythic'); used = true; break;
                // NEW FUNCTIONAL POWERS
                case 'gravitypull':
                    // Pull all nearby players and powerups toward you
                    const pullRadius = 400;
                    for (let id in state.players) {
                        const p = state.players[id];
                        const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                        if (dist < pullRadius && dist > 0) {
                            socket.emit('playerHit', { targetId: id, damage: 20, attackerId: myId });
                        }
                    }
                    // Visual effect
                    for (let i = 0; i < 40; i++) {
                        const angle = (i / 40) * Math.PI * 2;
                        const dist = pullRadius;
                        spawnParticles(
                            state.me.x + Math.cos(angle) * dist, 
                            state.me.y + Math.sin(angle) * dist, 
                            2, '#7c3aed'
                        );
                    }
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 50, maxRadius: pullRadius, life: 1, color: '#7c3aed' });
                    socket.emit('abilityUsed', { type: 'gravitypull', x: state.me.x, y: state.me.y, id: myId });
                    tryDamageBoss(state.me.x, state.me.y, pullRadius, 20);
                    tryDamageNPCs(state.me.x, state.me.y, pullRadius, 20);
                    showToast('Gravity Pull!', 'mythic'); used = true; break;
                case 'mirror':
                    // Reflect projectiles back at attackers
                    state.mirrorActive = true;
                    state.omegaTimer = 8; // 8 seconds of reflection
                    for (let i = 0; i < 20; i++) {
                        const angle = (i / 20) * Math.PI * 2;
                        spawnParticles(
                            state.me.x + Math.cos(angle) * 50, 
                            state.me.y + Math.sin(angle) * 50, 
                            2, '#c0c0c0'
                        );
                    }
                    socket.emit('abilityUsed', { type: 'mirror', x: state.me.x, y: state.me.y, id: myId });
                    updateScreenEffects();
                    showToast('Mirror Shield Active!', 'mythic'); used = true; break;
                case 'chaos':
                    // Random teleport and damage in area
                    const chaosX = state.mouse.worldX;
                    const chaosY = state.mouse.worldY;
                    // Teleport self randomly
                    state.me.x = 100 + Math.random() * (CONFIG.map.width - 200);
                    state.me.y = 100 + Math.random() * (CONFIG.map.height - 200);
                    spawnParticles(chaosX, chaosY, 50, '#ec4899');
                    spawnParticles(state.me.x, state.me.y, 50, '#ec4899');
                    socket.emit('abilityUsed', { type: 'chaos', x: chaosX, y: chaosY, id: myId });
                    // Damage in area at click location
                    for (let id in state.players) {
                        const p = state.players[id];
                        const dist = Math.sqrt((chaosX - p.x)**2 + (chaosY - p.y)**2);
                        if (dist < 250) {
                            socket.emit('playerHit', { targetId: id, damage: 45, attackerId: myId });
                        }
                    }
                    state.explosions.push({ x: chaosX, y: chaosY, radius: 30, maxRadius: 250, life: 1, color: '#ec4899' });
                    tryDamageBoss(chaosX, chaosY, 250, 45);
                    tryDamageNPCs(chaosX, chaosY, 250, 45);
                    showToast('CHAOS ORB!', 'mythic'); used = true; break;
                case 'lightning':
                    // Strike lightning at mouse position - doesn't damage self
                    const ltx = state.mouse.worldX, lty = state.mouse.worldY;
                    const ltPts = Array.from({length:3}, () => ({ x: ltx + (Math.random()-0.5)*80, y: lty + (Math.random()-0.5)*80 }));
                    socket.emit('abilityUsed', { type: 'lightning', x: ltx, y: lty, id: myId, pts: ltPts });
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const boltX = ltPts[i].x, boltY = ltPts[i].y;
                            state.explosions.push({ x: boltX, y: boltY, radius: 5, maxRadius: 80, life: 0.5, color: '#facc15' });
                            spawnParticles(boltX, boltY, 20, '#facc15');
                            for (let id in state.players) {
                                const p = state.players[id];
                                if (Math.sqrt((boltX-p.x)**2+(boltY-p.y)**2) < 90) {
                                    socket.emit('playerHit', { targetId: id, damage: 35, attackerId: myId });
                                    spawnParticles(p.x, p.y, 15, '#facc15');
                                }
                            }
                            tryDamageBoss(boltX, boltY, 90, 35);
                            tryDamageNPCs(boltX, boltY, 90, 35);
                        }, i * 120);
                    }
                    showToast('LIGHTNING STRIKE!', 'mythic'); used = true; break;
                case 'baby':
                    // Spawn a baby mini-player
                    if (state.baby) { showToast('Baby already active!', 'mythic'); return; }
                    state.baby = {
                        x: state.me.x + 60, y: state.me.y + 60,
                        hp: 50, angle: 0, shootCooldown: 0,
                        targetX: state.mouse.worldX, targetY: state.mouse.worldY
                    };
                    document.getElementById('baby-controls').classList.add('visible');
                    spawnParticles(state.baby.x, state.baby.y, 30, '#ff69b4');
                    socket.emit('abilityUsed', { type: 'babyspawn', x: state.baby.x, y: state.baby.y, id: myId });
                    showToast('Baby spawned! Drag your mouse to guide it.', 'mythic');
                    used = true; break;
                case 'soulsteal':
                    // Drain HP from all nearby players and gain it back
                    let stolen = 0;
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 30, maxRadius: 350, life: 1.2, color: '#8800ff' });
                    for (let id in state.players) {
                        const p = state.players[id];
                        const dist = Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2);
                        if (dist < 350) {
                            const drain = 40;
                            socket.emit('playerHit', { targetId: id, damage: drain, attackerId: myId });
                            spawnParticles(p.x, p.y, 15, '#8800ff');
                            stolen += drain;
                        }
                    }
                    state.me.hp = Math.min(100, state.me.hp + stolen);
                    spawnParticles(state.me.x, state.me.y, 40, '#8800ff');
                    emitAbilityEffect('soulrip', state.me.x, state.me.y);
                    if (stolen > 0) spawnDamageNumber(state.me.x, state.me.y, stolen, 'heal');
                    tryDamageBoss(state.me.x, state.me.y, 350, 60);
                    tryDamageNPCs(state.me.x, state.me.y, 350, 60);
                    showToast('SOUL STEAL! Life drained!', 'mythic'); used = true; break;
                case 'phoenix':
                    showToast('Phoenix: You will auto-revive on death!', 'mythic'); return;
                // ADMIN POWERS - ACTUALLY DEVASTATING
                case 'apocalypse':
                    // Screen-wide devastation - pre-generate positions for sync
                    const apocPts = Array.from({length:30}, () => ({ x: Math.random()*CONFIG.map.width, y: Math.random()*CONFIG.map.height }));
                    socket.emit('abilityUsed', { type: 'apocalypse', x: state.me.x, y: state.me.y, id: myId, pts: apocPts });
                    for (let i = 0; i < 30; i++) {
                        const rx = apocPts[i].x, ry = apocPts[i].y;
                        setTimeout(() => {
                            state.explosions.push({ x: rx, y: ry, radius: 40, maxRadius: 300, life: 1, color: '#ff0000' });
                            for (let id in state.players) {
                                const p = state.players[id];
                                if (Math.sqrt((rx - p.x)**2 + (ry - p.y)**2) < 300) {
                                    socket.emit('playerHit', { targetId: id, damage: 40, attackerId: myId });
                                }
                            }
                        }, i * 200);
                    }
                    showToast('APOCALYPSE', 'admin'); used = true; break;
                case 'chronobreak':
                    state.timestopActive = true;
                    state.omegaTimer = 10;
                    const cbPts = Array.from({length:100}, () => ({ x: state.me.x + (Math.random()-0.5)*500, y: state.me.y + (Math.random()-0.5)*500 }));
                    cbPts.forEach(pt => spawnParticles(pt.x, pt.y, 1, '#00ffff'));
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 50, maxRadius: 400, life: 2, color: '#00ffff' });
                    socket.emit('abilityUsed', { type: 'chronobreak', x: state.me.x, y: state.me.y, id: myId, pts: cbPts });
                    updateScreenEffects();
                    showToast('CHRONO BREAK', 'admin'); used = true; break;
                case 'voidrift':
                    // Teleport all players randomly
                    for (let id in state.players) {
                        const newX = 200 + Math.random() * (CONFIG.map.width - 400);
                        const newY = 200 + Math.random() * (CONFIG.map.height - 400);
                        spawnParticles(state.players[id].x, state.players[id].y, 30, '#9333ea');
                        socket.emit('playerHit', { targetId: id, damage: 30, attackerId: myId });
                    }
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 100, maxRadius: 800, life: 2, color: '#9333ea' });
                    socket.emit('abilityUsed', { type: 'voidrift', x: state.me.x, y: state.me.y, id: myId });
                    showToast('VOID RIFT', 'admin'); used = true; break;
                case 'armageddon':
                    // Massive meteor storm - pre-generate positions
                    const armaPts = Array.from({length:40}, (_, i) => ({ x: Math.random()*CONFIG.map.width, y: Math.random()*CONFIG.map.height, delay: i*100 }));
                    socket.emit('abilityUsed', { type: 'armageddon', x: state.me.x, y: state.me.y, id: myId, pts: armaPts });
                    for (let i = 0; i < 40; i++) {
                        setTimeout(() => {
                            state.meteors.push({ x: armaPts[i].x, y: -400, targetY: armaPts[i].y, speed: 1200 });
                        }, armaPts[i].delay);
                    }
                    showToast('ARMAGEDDON', 'admin'); used = true; break;
                case 'omegabeam':
                    // Giant laser across map
                    const beamAngle = state.me.angle;
                    socket.emit('abilityUsed', { type: 'omegabeam', x: state.me.x, y: state.me.y, angle: beamAngle, id: myId });
                    for (let i = 0; i < 100; i++) {
                        const beamDist = i * 50;
                        const beamX = state.me.x + Math.cos(beamAngle) * beamDist;
                        const beamY = state.me.y + Math.sin(beamAngle) * beamDist;
                        spawnParticles(beamX, beamY, 5, '#06b6d4');
                        for (let id in state.players) {
                            const p = state.players[id];
                            if (Math.sqrt((beamX - p.x)**2 + (beamY - p.y)**2) < 60) {
                                socket.emit('playerHit', { targetId: id, damage: 100, attackerId: myId });
                            }
                        }
                    }
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 50, maxRadius: 5000, life: 1.5, color: '#06b6d4' });
                    showToast('OMEGA BEAM', 'admin'); used = true; break;
                case 'singularity':
                    // Massive black hole
                    const singX = state.mouse.worldX;
                    const singY = state.mouse.worldY;
                    state.explosions.push({ x: singX, y: singY, radius: 10, maxRadius: 600, life: 5, color: '#000000' });
                    socket.emit('abilityUsed', { type: 'singularity', x: singX, y: singY, id: myId });
                    for (let wave = 0; wave < 10; wave++) {
                        setTimeout(() => {
                            for (let id in state.players) {
                                const p = state.players[id];
                                if (Math.sqrt((singX - p.x)**2 + (singY - p.y)**2) < 600) {
                                    socket.emit('playerHit', { targetId: id, damage: 15, attackerId: myId });
                                }
                            }
                            spawnParticles(singX, singY, 30, '#000000');
                        }, wave * 500);
                    }
                    showToast('SINGULARITY', 'admin'); used = true; break;
                case 'realitybomb':
                    // Warp space
                    socket.emit('abilityUsed', { type: 'realitybomb', x: state.me.x, y: state.me.y, id: myId });
                    for (let i = 0; i < 20; i++) {
                        setTimeout(() => {
                            const bombDist = (i / 20) * 500;
                            for (let angle = 0; angle < Math.PI * 2; angle += 0.5) {
                                const bx = state.me.x + Math.cos(angle) * bombDist;
                                const by = state.me.y + Math.sin(angle) * bombDist;
                                spawnParticles(bx, by, 5, '#ec4899');
                                for (let id in state.players) {
                                    const p = state.players[id];
                                    if (Math.sqrt((bx - p.x)**2 + (by - p.y)**2) < 80) {
                                        socket.emit('playerHit', { targetId: id, damage: 20, attackerId: myId });
                                    }
                                }
                            }
                        }, i * 50);
                    }
                    showToast('REALITY BOMB', 'admin'); used = true; break;
                case 'godmode':
                    state.adminGodMode = true;
                    state.me.hp = 100;
                    socket.emit('abilityUsed', { type: 'godmode', x: state.me.x, y: state.me.y, id: myId });
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            state.explosions.push({ x: state.me.x, y: state.me.y, radius: 50, maxRadius: 400, life: 0.5, color: '#ffd700' });
                            for (let id in state.players) {
                                const p = state.players[id];
                                if (Math.sqrt((state.me.x - p.x)**2 + (state.me.y - p.y)**2) < 400) {
                                    socket.emit('playerHit', { targetId: id, damage: 50, attackerId: myId });
                                }
                            }
                        }, i * 300);
                    }
                    setTimeout(() => { state.adminGodMode = false; }, 5000);
                    showToast('GOD MODE', 'admin'); used = true; break;
                case 'obliterate':
                    // Instant kill everyone
                    const oblPts = Array.from({length:10}, () => ({ x: Math.random()*CONFIG.map.width, y: Math.random()*CONFIG.map.height }));
                    socket.emit('abilityUsed', { type: 'obliterate', x: state.me.x, y: state.me.y, id: myId, pts: oblPts });
                    for (let id in state.players) {
                        socket.emit('playerHit', { targetId: id, damage: 9999, attackerId: myId });
                        spawnParticles(state.players[id].x, state.players[id].y, 50, '#dc2626');
                    }
                    for (let i = 0; i < 10; i++) {
                        state.explosions.push({ x: oblPts[i].x, y: oblPts[i].y, radius: 100, maxRadius: 600, life: 1, color: '#dc2626' });
                    }
                    showToast('OBLITERATE', 'admin'); used = true; break;
                // NEW UNRELEASED ADMIN POWERS FOR DEMONSTRATION
                case 'dimensionrift':
                    // Swap positions of all players randomly
                    const positions = [];
                    for (let id in state.players) {
                        positions.push({ x: state.players[id].x, y: state.players[id].y });
                    }
                    // Shuffle positions
                    positions.sort(() => Math.random() - 0.5);
                    let posIdx = 0;
                    for (let id in state.players) {
                        const newPos = positions[posIdx++];
                        spawnParticles(state.players[id].x, state.players[id].y, 40, '#8b00ff');
                        spawnParticles(newPos.x, newPos.y, 40, '#8b00ff');
                        socket.emit('playerHit', { targetId: id, damage: 35, attackerId: myId });
                    }
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 100, maxRadius: 1000, life: 2, color: '#8b00ff' });
                    socket.emit('abilityUsed', { type: 'dimensionrift', x: state.me.x, y: state.me.y, id: myId });
                    showToast('DIMENSION RIFT', 'admin'); used = true; break;
                case 'cosmicstorm':
                    // Massive area denial with rotating lasers
                    socket.emit('abilityUsed', { type: 'cosmicstorm', x: state.me.x, y: state.me.y, id: myId });
                    for (let wave = 0; wave < 8; wave++) {
                        setTimeout(() => {
                            const angle = (wave / 8) * Math.PI * 2;
                            for (let dist = 0; dist < 1000; dist += 50) {
                                const beamX = state.me.x + Math.cos(angle) * dist;
                                const beamY = state.me.y + Math.sin(angle) * dist;
                                spawnParticles(beamX, beamY, 5, '#ff1493');
                                for (let id in state.players) {
                                    const p = state.players[id];
                                    if (Math.sqrt((beamX - p.x)**2 + (beamY - p.y)**2) < 80) {
                                        socket.emit('playerHit', { targetId: id, damage: 30, attackerId: myId });
                                    }
                                }
                            }
                        }, wave * 300);
                    }
                    showToast('COSMIC STORM', 'admin'); used = true; break;
                case 'infinityvoid':
                    // Create expanding void that pulls and damages
                    const voidX = state.mouse.worldX;
                    const voidY = state.mouse.worldY;
                    socket.emit('abilityUsed', { type: 'infinityvoid', x: voidX, y: voidY, id: myId });
                    for (let wave = 0; wave < 15; wave++) {
                        setTimeout(() => {
                            const radius = wave * 40;
                            state.explosions.push({ x: voidX, y: voidY, radius: radius, maxRadius: radius + 100, life: 0.5, color: '#000033' });
                            for (let id in state.players) {
                                const p = state.players[id];
                                const dist = Math.sqrt((voidX - p.x)**2 + (voidY - p.y)**2);
                                if (dist < radius + 100) {
                                    socket.emit('playerHit', { targetId: id, damage: 20, attackerId: myId });
                                }
                            }
                            spawnParticles(voidX, voidY, 30, '#000033');
                        }, wave * 200);
                    }
                    showToast('INFINITY VOID', 'admin'); used = true; break;
                case 'starforge':
                    // Create multiple suns that damage over time
                    socket.emit('abilityUsed', { type: 'starforge', x: state.me.x, y: state.me.y, id: myId });
                    for (let i = 0; i < 5; i++) {
                        const sunX = state.me.x + Math.cos(i * Math.PI * 0.4) * 300;
                        const sunY = state.me.y + Math.sin(i * Math.PI * 0.4) * 300;
                        for (let tick = 0; tick < 20; tick++) {
                            setTimeout(() => {
                                state.explosions.push({ x: sunX, y: sunY, radius: 50, maxRadius: 150, life: 0.5, color: '#ffdf00' });
                                for (let id in state.players) {
                                    const p = state.players[id];
                                    if (Math.sqrt((sunX - p.x)**2 + (sunY - p.y)**2) < 150) {
                                        socket.emit('playerHit', { targetId: id, damage: 15, attackerId: myId });
                                    }
                                }
                                spawnParticles(sunX, sunY, 10, '#ffdf00');
                            }, (i * 500) + (tick * 200));
                        }
                    }
                    showToast('STAR FORGE', 'admin'); used = true; break;
                case 'quantumcollapse':
                    // Collapse reality - multiple effects at once - pre-generate random positions
                    const qcPts = Array.from({length:30}, () => ({ x: Math.random()*CONFIG.map.width, y: Math.random()*CONFIG.map.height }));
                    socket.emit('abilityUsed', { type: 'quantumcollapse', x: state.me.x, y: state.me.y, id: myId, pts: qcPts });
                    for (let i = 0; i < 100; i++) {
                        spawnParticles(qcPts[i % 30].x, qcPts[i % 30].y, 1, '#00fff7');
                    }
                    // Effect 2: Massive damage waves
                    for (let wave = 0; wave < 6; wave++) {
                        setTimeout(() => {
                            for (let id in state.players) {
                                socket.emit('playerHit', { targetId: id, damage: 40, attackerId: myId });
                                spawnParticles(state.players[id].x, state.players[id].y, 30, '#00fff7');
                            }
                            // Use pre-generated explosion positions
                            for (let j = 0; j < 5; j++) {
                                const pt = qcPts[(wave*5+j) % 30];
                                state.explosions.push({ x: pt.x, y: pt.y, radius: 50, maxRadius: 400, life: 1, color: '#00fff7' });
                            }
                        }, wave * 400);
                    }
                    showToast('QUANTUM COLLAPSE', 'admin'); used = true; break;
                case 'worldender':
                    // Massive ring of explosions across entire map
                    socket.emit('abilityUsed', { type: 'worldender', x: state.me.x, y: state.me.y, id: myId });
                    for (let ring = 0; ring < 5; ring++) {
                        setTimeout(() => {
                            for (let i = 0; i < 12; i++) {
                                const angle = (i / 12) * Math.PI * 2;
                                const r = (ring + 1) * 400;
                                const wx = state.me.x + Math.cos(angle) * r;
                                const wy = state.me.y + Math.sin(angle) * r;
                                state.explosions.push({ x: wx, y: wy, radius: 50, maxRadius: 300, life: 1, color: '#b91c1c' });
                                for (let id in state.players) {
                                    if (Math.sqrt((wx-state.players[id].x)**2+(wy-state.players[id].y)**2) < 300)
                                        socket.emit('playerHit', { targetId: id, damage: 35, attackerId: myId });
                                }
                            }
                        }, ring * 250);
                    }
                    showToast('WORLD ENDER', 'admin'); used = true; break;
                case 'divinebeam':
                    // Beam from above targeting all enemies
                    socket.emit('abilityUsed', { type: 'divinebeam', x: state.me.x, y: state.me.y, id: myId });
                    for (let id in state.players) {
                        const p = state.players[id];
                        const pxSnap = p.x, pySnap = p.y;
                        socket.emit('abilityUsed', { type: 'divinebeamtarget', x: pxSnap, y: pySnap, id: myId });
                        for (let tick = 0; tick < 10; tick++) {
                            setTimeout(() => {
                                spawnParticles(pxSnap, pySnap - tick*30, 5, '#f0abfc');
                                state.explosions.push({ x: pxSnap, y: pySnap, radius: 10, maxRadius: 60, life: 0.4, color: '#f0abfc' });
                                socket.emit('playerHit', { targetId: id, damage: 10, attackerId: myId });
                            }, tick * 100);
                        }
                    }
                    showToast('DIVINE BEAM', 'admin'); used = true; break;
                case 'blacksun':
                    // Create a massive darkness that damages all
                    state.explosions.push({ x: state.me.x, y: state.me.y, radius: 50, maxRadius: 2000, life: 3, color: '#1c1c1c' });
                    socket.emit('abilityUsed', { type: 'blacksun', x: state.me.x, y: state.me.y, id: myId });
                    for (let wave = 0; wave < 10; wave++) {
                        setTimeout(() => {
                            for (let id in state.players) {
                                socket.emit('playerHit', { targetId: id, damage: 25, attackerId: myId });
                            }
                            spawnParticles(state.me.x, state.me.y, 20, '#1c1c1c');
                        }, wave * 200);
                    }
                    showToast('BLACK SUN', 'admin'); used = true; break;
                case 'stormcall':
                    // Lightning strikes randomly across map - pre-generate positions
                    const scPts = Array.from({length:20}, () => ({ x: Math.random()*CONFIG.map.width, y: Math.random()*CONFIG.map.height }));
                    socket.emit('abilityUsed', { type: 'stormcall', x: state.me.x, y: state.me.y, id: myId, pts: scPts });
                    for (let bolt = 0; bolt < 20; bolt++) {
                        setTimeout(() => {
                            const bx = scPts[bolt].x, by = scPts[bolt].y;
                            state.explosions.push({ x: bx, y: by, radius: 5, maxRadius: 120, life: 0.4, color: '#60a5fa' });
                            spawnParticles(bx, by, 10, '#60a5fa');
                            for (let id in state.players) {
                                if (Math.sqrt((bx-state.players[id].x)**2+(by-state.players[id].y)**2) < 120)
                                    socket.emit('playerHit', { targetId: id, damage: 30, attackerId: myId });
                            }
                            tryDamageNPCs(bx, by, 120, 30);
                        }, bolt * 150);
                    }
                    showToast('STORM CALL', 'admin'); used = true; break;
            }
            if (used && !state.adminInfinite) {
                state.me.currentPower = null; state.me.isOmegaPower = false; state.me.isAdminPower = false;
                state.speedActive = false; state.phaseActive = false; state.berserkerActive = false;
                updatePowerUI(null); broadcastState();
            }
            // All used powers damage the boss and NPCs ‚Äî admin powers hit much harder
            if (used) {
                const isAdmin = ADMIN_POWERS[powerType];
                tryDamageBoss(state.me.x, state.me.y, isAdmin ? 2000 : 300, isAdmin ? 150 : 25);
                tryDamageNPCs(state.me.x, state.me.y, isAdmin ? 2000 : 300, isAdmin ? 150 : 25);
            }
        }

        function tryDrop() {
            const droppedPower = state.inventory[state.activeSlot];
            if (!state.me || !droppedPower) {
                showToast('Nothing to drop!', 'warning'); return;
            }
            const powerInfo = ALL_POWERS[droppedPower];
            // Only Omega powers can't be dropped - they vanish
            if (state.me.isOmegaPower && OMEGA_POWER[droppedPower]) {
                spawnParticles(state.me.x, state.me.y, 20, powerInfo.color);
                showToast(`${powerInfo.name} destroyed!`, 'mythic');
                state.inventory[state.activeSlot] = null;
                state.me.currentPower = null; state.me.isOmegaPower = false;
                updateInventoryUI(); broadcastState(); return;
            }
            const dropId = 'drop_' + (powerupIdCounter++);
            const dropX = state.me.x + Math.cos(state.me.angle + Math.PI) * 50;
            const dropY = state.me.y + Math.sin(state.me.angle + Math.PI) * 50;
            state.powerups[dropId] = {
                id: dropId, type: droppedPower,
                x: Math.max(50, Math.min(CONFIG.map.width - 50, dropX)),
                y: Math.max(50, Math.min(CONFIG.map.height - 50, dropY))
            };
            socket.emit('dropPower', { type: droppedPower, x: state.powerups[dropId].x, y: state.powerups[dropId].y });
            spawnParticles(state.me.x, state.me.y, 10, powerInfo.color);
            state.inventory[state.activeSlot] = null;
            state.slotCooldowns[state.activeSlot] = 0;
            state.speedActive = false;
            state.phaseActive = false; state.berserkerActive = false;
            state.me.currentPower = state.inventory[state.activeSlot];
            updateInventoryUI(); broadcastState();
            showToast(`Dropped ${powerInfo.name}!`, 'mythic');
        }

        function recallBaby() {
            if (!state.baby) return;
            spawnParticles(state.baby.x, state.baby.y, 20, '#ff69b4');
            socket.emit('abilityUsed', { type: 'babyrecall', x: state.baby.x, y: state.baby.y, id: myId });
            state.baby = null;
            document.getElementById('baby-controls').classList.remove('visible');
            showToast('Baby recalled!', 'mythic');
        }

        function destructBaby() {
            if (!state.baby) return;
            state.explosions.push({ x: state.baby.x, y: state.baby.y, radius: 20, maxRadius: 200, life: 0.8, color: '#ff69b4' });
            for (let i = 0; i < 40; i++) spawnParticles(state.baby.x, state.baby.y, 1, '#ff69b4');
            for (let id in state.players) {
                const p = state.players[id];
                if (Math.sqrt((state.baby.x-p.x)**2+(state.baby.y-p.y)**2) < 200) {
                    socket.emit('playerHit', { targetId: id, damage: 40, attackerId: myId });
                }
            }
            socket.emit('abilityUsed', { type: 'babydestruct', x: state.baby.x, y: state.baby.y, id: myId });
            emitAbilityEffect('shockwave', state.baby.x, state.baby.y);
            state.baby = null;
            document.getElementById('baby-controls').classList.remove('visible');
            showToast('Baby self-destructed!', 'mythic');
        }

        function sendChat() {
            const input = document.getElementById('chat-input');
            const txt = input.value.trim();
            if (txt && state.me && socket) {
                socket.emit('chatMessage', { text: txt, playerName: state.me.name });
                input.value = ''; input.blur();
            }
        }

        window.onload = initSupabase;
    </script>
</body>
</html>
